This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
app.js
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/body/body.dbproj
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/body/library/20.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/body/library/body_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/body/library/body_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2010600a/2010600a.dbproj
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2010600a/library/2010600a_1_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2010600a/library/2010600a_1_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2010600a/library/2010600a_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2010600a/library/2010600a_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20208003/20208003.dbproj
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20208003/library/20208003_1_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20208003/library/20208003_1_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20208003/library/20208003_2_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20208003/library/20208003_2_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20208003/library/20208003_3_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20208003/library/20208003_3_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20208003/library/20208003_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20208003/library/20208003_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20208003/library/20405006_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20208003/library/20405006_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20509005/20509005.dbproj
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20509005/library/20509005_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20509005/library/20509005_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20703016/20703016.dbproj
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20703016/library/20703016_1_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20703016/library/20703016_1_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20703016/library/20703016_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20703016/library/20703016_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080100e/2080100e.dbproj
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080100e/library/2080100c_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080100e/library/2080100c_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080100e/library/2080100e_1_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080100e/library/2080100e_1_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080100e/library/2080100e_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080100e/library/2080100e_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080100e/library/20803005_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080100e/library/20803005_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080500b/2080500b.dbproj
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080500b/library/2080500b_1_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080500b/library/2080500b_1_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080500b/library/2080500b_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080500b/library/2080500b_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20106010/20106010.dbproj
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20106010/library/20106010_1_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20106010/library/20106010_1_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20106010/library/20106010_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20106010/library/20106010_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20208006/20208006.dbproj
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20208006/library/20208006_1_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20208006/library/20208006_1_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20208006/library/20208006_2_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20208006/library/20208006_2_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20208006/library/20208006_3_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20208006/library/20208006_3_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20208006/library/20208006_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20208006/library/20208006_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20208006/library/2040600b_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20208006/library/2040600b_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20509007/20509007.dbproj
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20509007/library/20509007_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20509007/library/20509007_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20703020/20703020.dbproj
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20703020/library/20703020_1_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20703020/library/20703020_1_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20703020/library/20703020_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20703020/library/20703020_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20801015/20801015.dbproj
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20801015/library/20801015_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20801015/library/20801015_tex.png
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/2080b003/2080b003.dbproj
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/2080b003/library/2080b003_tex.json
assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/2080b003/library/2080b003_tex.png
assets/city/building_large.png
assets/city/building_medium.png
assets/city/building_small.png
assets/city/fountain.png
assets/city/grass.png
assets/city/house.png
assets/city/plaza.png
assets/city/river.png
assets/city/road_center.png
assets/city/road_corner.png
assets/city/road.png
assets/city/shop_large.png
assets/city/shop_small.png
assets/city/svg/building_large.svg
assets/city/svg/building_medium.svg
assets/city/svg/building_small.svg
assets/city/svg/fountain.svg
assets/city/svg/grass.svg
assets/city/svg/house.svg
assets/city/svg/plaza.svg
assets/city/svg/road_center.svg
assets/city/svg/road_corner.svg
assets/city/svg/road.svg
assets/city/svg/shop.svg
assets/city/svg/water.svg
assets/city/water.png
assets/classic/1024.jpg
assets/classic/128.jpg
assets/classic/16.jpg
assets/classic/16384.jpg
assets/classic/2.jpg
assets/classic/2048.jpg
assets/classic/256.jpg
assets/classic/32.jpg
assets/classic/32768.jpg
assets/classic/4.jpg
assets/classic/4096.jpg
assets/classic/512.jpg
assets/classic/64.jpg
assets/classic/8.jpg
assets/classic/8192.jpg
assets/kenney_isometric-city.zip
assets/kenney_isometric-city/Details/cityDetails_000.png
assets/kenney_isometric-city/Details/cityDetails_001.png
assets/kenney_isometric-city/Details/cityDetails_002.png
assets/kenney_isometric-city/Details/cityDetails_003.png
assets/kenney_isometric-city/Details/cityDetails_004.png
assets/kenney_isometric-city/Details/cityDetails_005.png
assets/kenney_isometric-city/Details/cityDetails_006.png
assets/kenney_isometric-city/Details/cityDetails_007.png
assets/kenney_isometric-city/Details/cityDetails_008.png
assets/kenney_isometric-city/Details/cityDetails_009.png
assets/kenney_isometric-city/Details/cityDetails_010.png
assets/kenney_isometric-city/Donate.url
assets/kenney_isometric-city/Facebook.url
assets/kenney_isometric-city/License.txt
assets/kenney_isometric-city/PNG/cityTiles_000.png
assets/kenney_isometric-city/PNG/cityTiles_001.png
assets/kenney_isometric-city/PNG/cityTiles_002.png
assets/kenney_isometric-city/PNG/cityTiles_003.png
assets/kenney_isometric-city/PNG/cityTiles_004.png
assets/kenney_isometric-city/PNG/cityTiles_005.png
assets/kenney_isometric-city/PNG/cityTiles_006.png
assets/kenney_isometric-city/PNG/cityTiles_007.png
assets/kenney_isometric-city/PNG/cityTiles_008.png
assets/kenney_isometric-city/PNG/cityTiles_009.png
assets/kenney_isometric-city/PNG/cityTiles_010.png
assets/kenney_isometric-city/PNG/cityTiles_011.png
assets/kenney_isometric-city/PNG/cityTiles_012.png
assets/kenney_isometric-city/PNG/cityTiles_013.png
assets/kenney_isometric-city/PNG/cityTiles_014.png
assets/kenney_isometric-city/PNG/cityTiles_015.png
assets/kenney_isometric-city/PNG/cityTiles_016.png
assets/kenney_isometric-city/PNG/cityTiles_017.png
assets/kenney_isometric-city/PNG/cityTiles_018.png
assets/kenney_isometric-city/PNG/cityTiles_019.png
assets/kenney_isometric-city/PNG/cityTiles_020.png
assets/kenney_isometric-city/PNG/cityTiles_021.png
assets/kenney_isometric-city/PNG/cityTiles_022.png
assets/kenney_isometric-city/PNG/cityTiles_023.png
assets/kenney_isometric-city/PNG/cityTiles_024.png
assets/kenney_isometric-city/PNG/cityTiles_025.png
assets/kenney_isometric-city/PNG/cityTiles_026.png
assets/kenney_isometric-city/PNG/cityTiles_027.png
assets/kenney_isometric-city/PNG/cityTiles_028.png
assets/kenney_isometric-city/PNG/cityTiles_029.png
assets/kenney_isometric-city/PNG/cityTiles_030.png
assets/kenney_isometric-city/PNG/cityTiles_031.png
assets/kenney_isometric-city/PNG/cityTiles_032.png
assets/kenney_isometric-city/PNG/cityTiles_033.png
assets/kenney_isometric-city/PNG/cityTiles_034.png
assets/kenney_isometric-city/PNG/cityTiles_035.png
assets/kenney_isometric-city/PNG/cityTiles_036.png
assets/kenney_isometric-city/PNG/cityTiles_037.png
assets/kenney_isometric-city/PNG/cityTiles_038.png
assets/kenney_isometric-city/PNG/cityTiles_039.png
assets/kenney_isometric-city/PNG/cityTiles_040.png
assets/kenney_isometric-city/PNG/cityTiles_041.png
assets/kenney_isometric-city/PNG/cityTiles_042.png
assets/kenney_isometric-city/PNG/cityTiles_043.png
assets/kenney_isometric-city/PNG/cityTiles_044.png
assets/kenney_isometric-city/PNG/cityTiles_045.png
assets/kenney_isometric-city/PNG/cityTiles_046.png
assets/kenney_isometric-city/PNG/cityTiles_047.png
assets/kenney_isometric-city/PNG/cityTiles_048.png
assets/kenney_isometric-city/PNG/cityTiles_049.png
assets/kenney_isometric-city/PNG/cityTiles_050.png
assets/kenney_isometric-city/PNG/cityTiles_051.png
assets/kenney_isometric-city/PNG/cityTiles_052.png
assets/kenney_isometric-city/PNG/cityTiles_053.png
assets/kenney_isometric-city/PNG/cityTiles_054.png
assets/kenney_isometric-city/PNG/cityTiles_055.png
assets/kenney_isometric-city/PNG/cityTiles_056.png
assets/kenney_isometric-city/PNG/cityTiles_057.png
assets/kenney_isometric-city/PNG/cityTiles_058.png
assets/kenney_isometric-city/PNG/cityTiles_059.png
assets/kenney_isometric-city/PNG/cityTiles_060.png
assets/kenney_isometric-city/PNG/cityTiles_061.png
assets/kenney_isometric-city/PNG/cityTiles_062.png
assets/kenney_isometric-city/PNG/cityTiles_063.png
assets/kenney_isometric-city/PNG/cityTiles_064.png
assets/kenney_isometric-city/PNG/cityTiles_065.png
assets/kenney_isometric-city/PNG/cityTiles_066.png
assets/kenney_isometric-city/PNG/cityTiles_067.png
assets/kenney_isometric-city/PNG/cityTiles_068.png
assets/kenney_isometric-city/PNG/cityTiles_069.png
assets/kenney_isometric-city/PNG/cityTiles_070.png
assets/kenney_isometric-city/PNG/cityTiles_071.png
assets/kenney_isometric-city/PNG/cityTiles_072.png
assets/kenney_isometric-city/PNG/cityTiles_073.png
assets/kenney_isometric-city/PNG/cityTiles_074.png
assets/kenney_isometric-city/PNG/cityTiles_075.png
assets/kenney_isometric-city/PNG/cityTiles_076.png
assets/kenney_isometric-city/PNG/cityTiles_077.png
assets/kenney_isometric-city/PNG/cityTiles_078.png
assets/kenney_isometric-city/PNG/cityTiles_079.png
assets/kenney_isometric-city/PNG/cityTiles_080.png
assets/kenney_isometric-city/PNG/cityTiles_081.png
assets/kenney_isometric-city/PNG/cityTiles_082.png
assets/kenney_isometric-city/PNG/cityTiles_083.png
assets/kenney_isometric-city/PNG/cityTiles_084.png
assets/kenney_isometric-city/PNG/cityTiles_085.png
assets/kenney_isometric-city/PNG/cityTiles_086.png
assets/kenney_isometric-city/PNG/cityTiles_087.png
assets/kenney_isometric-city/PNG/cityTiles_088.png
assets/kenney_isometric-city/PNG/cityTiles_089.png
assets/kenney_isometric-city/PNG/cityTiles_090.png
assets/kenney_isometric-city/PNG/cityTiles_091.png
assets/kenney_isometric-city/PNG/cityTiles_092.png
assets/kenney_isometric-city/PNG/cityTiles_093.png
assets/kenney_isometric-city/PNG/cityTiles_094.png
assets/kenney_isometric-city/PNG/cityTiles_095.png
assets/kenney_isometric-city/PNG/cityTiles_096.png
assets/kenney_isometric-city/PNG/cityTiles_097.png
assets/kenney_isometric-city/PNG/cityTiles_098.png
assets/kenney_isometric-city/PNG/cityTiles_099.png
assets/kenney_isometric-city/PNG/cityTiles_100.png
assets/kenney_isometric-city/PNG/cityTiles_101.png
assets/kenney_isometric-city/PNG/cityTiles_102.png
assets/kenney_isometric-city/PNG/cityTiles_103.png
assets/kenney_isometric-city/PNG/cityTiles_104.png
assets/kenney_isometric-city/PNG/cityTiles_105.png
assets/kenney_isometric-city/PNG/cityTiles_106.png
assets/kenney_isometric-city/PNG/cityTiles_107.png
assets/kenney_isometric-city/PNG/cityTiles_108.png
assets/kenney_isometric-city/PNG/cityTiles_109.png
assets/kenney_isometric-city/PNG/cityTiles_110.png
assets/kenney_isometric-city/PNG/cityTiles_111.png
assets/kenney_isometric-city/PNG/cityTiles_112.png
assets/kenney_isometric-city/PNG/cityTiles_113.png
assets/kenney_isometric-city/PNG/cityTiles_114.png
assets/kenney_isometric-city/PNG/cityTiles_115.png
assets/kenney_isometric-city/PNG/cityTiles_116.png
assets/kenney_isometric-city/PNG/cityTiles_117.png
assets/kenney_isometric-city/PNG/cityTiles_118.png
assets/kenney_isometric-city/PNG/cityTiles_119.png
assets/kenney_isometric-city/PNG/cityTiles_120.png
assets/kenney_isometric-city/PNG/cityTiles_121.png
assets/kenney_isometric-city/PNG/cityTiles_122.png
assets/kenney_isometric-city/PNG/cityTiles_123.png
assets/kenney_isometric-city/PNG/cityTiles_124.png
assets/kenney_isometric-city/PNG/cityTiles_125.png
assets/kenney_isometric-city/PNG/cityTiles_126.png
assets/kenney_isometric-city/PNG/cityTiles_127.png
assets/kenney_isometric-city/Preview.png
assets/kenney_isometric-city/Spritesheet/cityDetails_sheet.png
assets/kenney_isometric-city/Spritesheet/cityDetails_sheet.xml
assets/kenney_isometric-city/Spritesheet/cityTiles_sheet.png
assets/kenney_isometric-city/Spritesheet/cityTiles_sheet.xml
assets/nature/1024.jpg
assets/nature/128.jpg
assets/nature/16.jpg
assets/nature/16384.jpg
assets/nature/2.jpg
assets/nature/2048.jpg
assets/nature/256.jpg
assets/nature/32.jpg
assets/nature/32768.jpg
assets/nature/4.jpg
assets/nature/4096.jpg
assets/nature/512.jpg
assets/nature/64.jpg
assets/nature/8.jpg
assets/nature/8192.jpg
city/src/CityScene.js
city/src/MinigameBase.js
core.js
design_rules.md
effects.js
GDD.md
index.html
jules/.gitignore
jules/index.html
jules/package.json
jules/public/assets/2048/1024.jpg
jules/public/assets/2048/128.jpg
jules/public/assets/2048/16.jpg
jules/public/assets/2048/16384.jpg
jules/public/assets/2048/2.jpg
jules/public/assets/2048/2048.jpg
jules/public/assets/2048/256.jpg
jules/public/assets/2048/32.jpg
jules/public/assets/2048/32768.jpg
jules/public/assets/2048/4.jpg
jules/public/assets/2048/4096.jpg
jules/public/assets/2048/512.jpg
jules/public/assets/2048/64.jpg
jules/public/assets/2048/8.jpg
jules/public/assets/2048/8192.jpg
jules/src/AssetLoader.js
jules/src/CityScene.js
jules/src/GameManager.js
jules/src/games/2048/Game2048.js
jules/src/games/2048/Logic.js
jules/src/games/2048/PixiRenderer.js
jules/src/main.js
jules/src/MinigameBase.js
jules/src/Viewport.js
jules/style.css
jules/test/test_2048_logic.js
manifest.json
notes/progress_2026-01-18.md
notes/progress_2026-01-19.md
notes/progress_20260118.md
package.json
README.md
roadmap.md
shop.json
src/core/FirebaseManager.js
src/core/GameInterface.js
src/core/LeaderboardManager.js
src/core/ThemeManager.js
src/games/2048/components/GameManager.js
src/games/2048/components/Grid.js
src/games/2048/components/HTMLActuator.js
src/games/2048/components/KeyboardInputManager.js
src/games/2048/components/LocalStorageManager.js
src/games/2048/components/PixiActuator.js
src/games/2048/components/PixiBoardRenderer.js
src/games/2048/components/Tile.js
src/games/2048/index.js
src/games/2048/style.css
style.css
styleguide.html
sw.js
TDD.md
ui/components.css
ui/theme.css
verification/after_merge.png
verification/before_merge.png
verification/during_animation.png
verification/verify_animations.py
verification/verify_particles.py
verification/verify_responsive.py
verification/verify_sliding.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
node_modules/
dist/
.DS_Store
.vscode/
</file>

<file path="app.js">
import { Photo2048 } from './src/games/2048/index.js';
import { CityScene } from './city/src/CityScene.js';
import { LeaderboardManager } from './src/core/LeaderboardManager.js';

(function () {
  "use strict";

  console.log("App Initialized v3");

  const views = {};
  const navButtons = [];
  let citySceneInstance = null;
  const state = {
    match3Score: 0,
    shopCatalog: null,
    shopItemsById: {},
    cityItems: []
  };
  const leaderboardManager = new LeaderboardManager({
    gameId: "2048",
    storageKey: "photo2048HighScores",
    limit: 20,
    firebaseManager: window.FirebaseManager
  });
  const playerNameKey = "arcadeCityPlayerName";
  let pendingScore = null;

  const games = {
      '2048': new Photo2048()
  };

  function showView(viewId) {
    Object.keys(views).forEach((id) => {
      views[id].classList.toggle("hidden", id !== viewId);
    });
    navButtons.forEach((button) => {
      button.classList.toggle("active", button.dataset.view === viewId);
    });
    
    // Game Lifecycle Management
    if (games[viewId]) {
        try {
            if (!games[viewId].container) {
                console.log(`Mounting game: ${viewId}`);
                games[viewId].mount(views[viewId]);
            } else {
                console.log(`Resuming game: ${viewId}`);
                games[viewId].resume();
            }
        } catch (err) {
            console.error(`Failed to mount/resume game ${viewId}:`, err);
        }
    } else {
        // Pause other games if they are running?
        Object.values(games).forEach(game => game.pause());
    }

    if (viewId === "city" && citySceneInstance && citySceneInstance.onShow) {
      citySceneInstance.onShow();
    }
  }

  function setupNav() {
    document.querySelectorAll("[data-view]").forEach((button) => {
      navButtons.push(button);
      button.addEventListener("click", () => {
        showView(button.dataset.view);
      });
    });
  }

  function setupViews() {
    ["2048", "city", "games", "shop"].forEach((id) => {
      const el = document.getElementById(`view-${id}`);
      if (el) {
        views[id] = el;
      }
    });
  }

  function setupGameLaunchers() {
    document.querySelectorAll("[data-launch]").forEach((button) => {
      button.addEventListener("click", () => {
        const viewId = button.dataset.launch;
        if (viewId) {
          showView(viewId);
        }
      });
    });
  }

  function setupMatch3Stub() {
    const scoreEl = document.getElementById("match3-score");
    const addButton = document.querySelector("[data-match3-add]");
    const resetButton = document.querySelector("[data-match3-reset]");
    if (!scoreEl || !addButton || !resetButton) return;

    const updateScore = (next) => {
      state.match3Score = Math.max(0, Math.floor(next));
      scoreEl.textContent = state.match3Score.toLocaleString();
      if (window.EconomyManager) {
        window.EconomyManager.awardFromScore("match3", state.match3Score);
      }
    };

    addButton.addEventListener("click", () => {
      updateScore(state.match3Score + 200);
    });

    resetButton.addEventListener("click", () => {
      updateScore(0);
    });
  }

  function setupPicrossStub() {
    const button = document.querySelector("[data-picross-complete]");
    if (!button) return;
    button.addEventListener("click", () => {
      if (window.EconomyManager) {
        window.EconomyManager.awardCompletion("picross", { size: "10x10" });
      }
    });
  }

  function showShopStatus(message, tone) {
    const status = document.getElementById("shop-status");
    if (!status) return;
    status.textContent = message || "";
    status.classList.toggle("hidden", !message);
    status.classList.toggle("ok", tone === "ok");
    status.classList.toggle("error", tone === "error");
  }

  function formatPrice(price) {
    return Number(price).toLocaleString();
  }

  function refreshShopCards() {
    const coins = window.EconomyManager ? window.EconomyManager.getCoins() : 0;
    document.querySelectorAll(".shop-item").forEach((card) => {
      const itemId = card.dataset.itemId;
      const item = state.shopItemsById[itemId];
      const button = card.querySelector("button");
      const owned = card.querySelector(".shop-owned span");
      if (owned && window.EconomyManager) {
        owned.textContent = window.EconomyManager.getItemCount(itemId).toLocaleString();
      }
      if (button && item) {
        const price = Math.floor(item.price || 0);
        button.disabled = price > coins;
      }
    });
  }

  function renderShopCategory(category) {
    const list = document.getElementById("shop-list");
    if (!list) return;

    const section = document.createElement("div");
    section.className = "shop-category";

    const header = document.createElement("div");
    header.className = "shop-category-header";
    header.innerHTML = `<h3>${category.label}</h3>`;
    section.appendChild(header);

    const grid = document.createElement("div");
    grid.className = "shop-grid";

    category.items.forEach((item) => {
      state.shopItemsById[item.id] = item;
      const card = document.createElement("div");
      card.className = "shop-item";
      card.dataset.itemId = item.id;

      const title = document.createElement("div");
      title.className = "shop-title";
      title.textContent = item.name;

      const meta = document.createElement("div");
      meta.className = "shop-meta";
      meta.textContent = item.type;

      const owned = document.createElement("div");
      owned.className = "shop-owned";
      owned.innerHTML = "Owned: <span>0</span>";

      const button = document.createElement("button");
      button.className = "ui-button small";
      button.textContent = `Buy ${formatPrice(item.price)}`;
      button.addEventListener("click", () => {
        if (!window.EconomyManager) return;
        const result = window.EconomyManager.purchaseItem(item);
        if (result.ok) {
          showShopStatus(`${item.name} added to inventory.`, "ok");
        } else {
          showShopStatus("Not enough coins.", "error");
        }
        refreshShopCards();
      });

      card.appendChild(title);
      card.appendChild(meta);
      card.appendChild(owned);
      card.appendChild(button);
      grid.appendChild(card);
    });

    section.appendChild(grid);
    list.appendChild(section);
  }

  function renderShop(catalog) {
    const list = document.getElementById("shop-list");
    if (!list) return;
    list.innerHTML = "";
    state.shopItemsById = {};
    (catalog.categories || []).forEach((category) => {
      renderShopCategory(category);
    });
    refreshShopCards();
  }

  function loadShopCatalog() {
    return fetch("./shop.json")
      .then((response) => response.json())
      .then((data) => {
        state.shopCatalog = data;
        state.cityItems = (data.categories || []).find((category) => category.id === "city")?.items || [];
        renderShop(data);
        return data;
      })
      .catch(() => {
        showShopStatus("Shop catalog failed to load.", "error");
      });
  }

  function setupCityScene() {
    const root = document.getElementById("city-root");
    const palette = document.getElementById("city-palette");
    const hint = document.getElementById("city-hint");
    
    // Legacy support for global CityScene if not modularized yet
    const CitySceneClass = CityScene; 
    
    if (!root || !palette || !CitySceneClass) return null;

    const scene = new CitySceneClass({
      root,
      palette,
      hint,
      gridSize: 64,
      storageKey: "arcadeCityLayout"
    });

    const modeButtons = document.querySelectorAll("[data-city-mode]");
    modeButtons.forEach((button) => {
      button.addEventListener("click", () => {
        modeButtons.forEach((btn) => btn.classList.remove("active"));
        button.classList.add("active");
        scene.setMode(button.dataset.cityMode);
      });
    });

    const clearButton = document.getElementById("city-clear");
    if (clearButton) {
      clearButton.addEventListener("click", () => {
        scene.clearLayout();
      });
    }

    const regenerateButton = document.getElementById("city-regenerate");
    if (regenerateButton) {
      regenerateButton.addEventListener("click", () => {
        if (scene.regenerateStarterCity) {
          scene.regenerateStarterCity();
        }
      });
    }

    const rotateButtons = document.querySelectorAll("[data-city-rotate]");
    rotateButtons.forEach((button) => {
      button.addEventListener("click", () => {
        const direction = button.dataset.cityRotate;
        scene.rotateSelection(direction === "left" ? -90 : 90);
      });
    });

    citySceneInstance = scene;
    return scene;
  }

  function bindEconomyEvents(cityScene) {
    if (!window.AppBus || !window.EconomyManager) return;
    window.AppBus.on("economy:changed", () => {
      refreshShopCards();
    });
    window.AppBus.on("economy:inventory", () => {
      refreshShopCards();
      if (cityScene) {
        cityScene.setInventory(window.EconomyManager.getInventory());
      }
    });
  }

  const dateFormatter = new Intl.DateTimeFormat(undefined, { month: "short", day: "numeric", year: "numeric" });
  let openLeaderboardRef = null;

  function setupSettingsOverlay() {
    const overlay = document.getElementById("settings-overlay");
    const openButtons = document.querySelectorAll("#settings-button");
    const closeButton = document.getElementById("close-settings");
    const pwaRefresh = document.getElementById("pwa-refresh");
    const devGameOver = document.getElementById("dev-game-over");
    const devAdd2048 = document.getElementById("dev-add-2048");
    if (!overlay) return;

    const close = () => overlay.classList.add("hidden");
    const open = () => overlay.classList.remove("hidden");

    if (openButtons.length) {
      openButtons.forEach((btn) => btn.addEventListener("click", open));
    }
    // Fallback delegation for dynamically created settings buttons
    document.addEventListener("click", (event) => {
      const target = event.target.closest && event.target.closest("#settings-button");
      if (target) {
        event.preventDefault();
        open();
      }
    });

    if (closeButton) closeButton.addEventListener("click", close);
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) close();
    });

    if (pwaRefresh) {
      pwaRefresh.addEventListener("click", () => {
        if ("serviceWorker" in navigator) {
          navigator.serviceWorker.getRegistration().then((reg) => {
            if (reg) {
              reg.update().finally(() => location.reload());
            } else {
              location.reload();
            }
          });
        } else {
          location.reload();
        }
      });
    }

    // Dev utilities now live in Settings
    if (devGameOver) {
      devGameOver.addEventListener("click", () => {
        const game = games["2048"];
        game?.forceGameOver?.();
      });
    }
    if (devAdd2048) {
      devAdd2048.addEventListener("click", () => {
        const game = games["2048"];
        game?.add2048Tile?.();
      });
    }
  }

  function setupLeaderboard() {
    const overlay = document.getElementById("leaderboard");
    const titleEl = document.getElementById("leaderboard-title");
    const closeBtn = document.getElementById("close-leaderboard");
    const clearBtn = document.getElementById("clear-leaderboard");
    const saveBtn = document.getElementById("save-score");
    const nameInput = document.getElementById("player-name");
    const entry = document.getElementById("leaderboard-entry");
    const pendingLabel = document.getElementById("leaderboard-pending");
    const hint = document.getElementById("leaderboard-hint");
    const status = document.getElementById("leaderboard-status");
    const tryAgainBtn = document.getElementById("leaderboard-try-again");
    let currentMode = "default";

    if (!overlay) return;

    const defaultName = localStorage.getItem(playerNameKey);
    if (defaultName && nameInput) {
      nameInput.value = defaultName;
    }

    function restartGame() {
      const restartBtn = document.querySelector("#view-2048 .restart-button");
      if (restartBtn) restartBtn.click();
      closeLeaderboard();
    }

    function setStatus(message, tone) {
      if (!status) return;
      status.textContent = message || "";
      status.classList.toggle("hidden", !message);
      status.classList.toggle("ok", tone === "ok");
      status.classList.toggle("error", tone === "error");
    }

    function toggleEntry(show) {
      if (!entry) return;
      entry.classList.toggle("hidden", !show);
      if (show && nameInput) {
        nameInput.focus();
        nameInput.select();
      }
    }

    async function renderLeaderboard() {
      const list = document.getElementById("high-score-list");
      if (!list) return;
      const { local, remote } = await leaderboardManager.fetchScores(10);
      const hasFirebase = !!(window.FirebaseManager && window.FirebaseManager.enabled);
      const indexRequired = !!(window.FirebaseManager && window.FirebaseManager.indexRequired);
      const hasRemote = Array.isArray(remote) && remote.length > 0;
      const rows = hasFirebase && hasRemote ? remote : local;

      if (hint && currentMode === "default") {
        if (indexRequired) {
          hint.textContent = "Firebase connected. Create the leaderboard composite index to sync cloud scores.";
        } else if (hasFirebase && hasRemote) {
          hint.textContent = "Live Firebase board. Falls back to local if offline.";
        } else if (hasFirebase) {
          hint.textContent = "Firebase connected. Showing local until cloud sync returns data.";
        } else {
          hint.textContent = "Local scores saved on-device. Add Firebase config to sync.";
        }
      }

      list.innerHTML = rows.length ? "" : "<li class='ui-list-item'>No scores yet</li>";

      const medals = ["ðŸ¥‡", "ðŸ¥ˆ", "ðŸ¥‰"];
      rows.forEach((entryItem, i) => {
        const li = document.createElement("li");
        li.className = "ui-list-item leader-card";
        const medal = medals[i] || "";
        const medalClass = i === 0 ? "gold" : i === 1 ? "silver" : i === 2 ? "bronze" : "";
        li.innerHTML = `
          <div class="lb-left">
            <div class="lb-rank ${medalClass}">${medal || i + 1}</div>
            <div class="lb-player">
              <div class="lb-name">${entryItem.name || "Player"}</div>
              <div class="lb-date ui-caption">${dateFormatter.format(new Date(entryItem.date || Date.now()))}</div>
            </div>
          </div>
          <div class="lb-right">
            <div class="lb-score">${Number(entryItem.score || 0).toLocaleString()}</div>
            <div class="lb-stat-stack">
              <div class="lb-stat">
                <span class="lb-stat-label">Undos</span>
                <span class="lb-stat-value">${Number(entryItem.undos || 0).toLocaleString()}</span>
              </div>
              <div class="lb-stat">
                <span class="lb-stat-label">Turns</span>
                <span class="lb-stat-value">${Number(entryItem.turns || 0).toLocaleString()}</span>
              </div>
            </div>
          </div>
        `;
        list.appendChild(li);
      });
    }

    async function openLeaderboard(options = {}) {
      currentMode = options.mode || "default";
      overlay.classList.remove("hidden");
      if (options.score !== undefined) {
        pendingScore = { score: Number(options.score) || 0, turns: Number(options.turns) || 0, undos: Number(options.undos) || 0, date: Date.now() };
      }
      const shouldShowEntry = options.showEntryForm ?? (pendingScore && leaderboardManager.isHighScore(pendingScore.score));
      if (shouldShowEntry && pendingLabel && pendingScore) {
        pendingLabel.textContent = `New high score: ${pendingScore.score.toLocaleString()}`;
      }
      if (closeBtn) {
        const isGameEnd = currentMode === "gameover" || currentMode === "win";
        // If the game ended, HIDE the button. Otherwise, SHOW it.
        closeBtn.style.display = isGameEnd ? "none" : "flex";
      }
      toggleEntry(!!shouldShowEntry);
      setStatus("", null);
      if (titleEl) {
        titleEl.textContent = currentMode === "gameover" ? "Game Over" : currentMode === "win" ? "You win!" : "Leaderboard";
      }
      if (tryAgainBtn) {
        tryAgainBtn.classList.toggle("hidden", !(currentMode === "gameover" || currentMode === "win"));
      }
      if (hint && (currentMode === "gameover" || currentMode === "win")) {
        hint.textContent = "Add your name to save this run, then try again.";
      }
      await renderLeaderboard();
    }

    async function handleSave(event) {
      event?.preventDefault();
      if (!pendingScore) return;
      const storedName = localStorage.getItem(playerNameKey);
      const name = (nameInput?.value || storedName || "Player").trim() || "Player";
      if (nameInput) nameInput.value = name;
      localStorage.setItem(playerNameKey, name);

      if (saveBtn) saveBtn.disabled = true;
      setStatus("Saving score...", null);

      try {
        const result = await leaderboardManager.submitScore(name, pendingScore.score, {
          turns: pendingScore.turns || 0,
          undos: pendingScore.undos || 0,
        });
        pendingScore = null;
        toggleEntry(false);
        if (result.remote.ok) {
          setStatus("Saved to Firebase + local.", "ok");
        } else if (result.localRank) {
          setStatus("Saved locally. Connect Firebase to sync online.", "ok");
        } else {
          setStatus("Score recorded locally.", "ok");
        }
        await renderLeaderboard();
      } catch (error) {
        setStatus("Could not save score. Try again.", "error");
      } finally {
        if (saveBtn) saveBtn.disabled = false;
      }
    }

    function closeLeaderboard() {
      overlay.classList.add("hidden");
      setStatus("", null);
      currentMode = "default";
    }

    if (closeBtn) {
      closeBtn.addEventListener("click", closeLeaderboard);
    }

    if (clearBtn) {
      clearBtn.addEventListener("click", () => {
        if (confirm("Clear local high scores?")) {
          leaderboardManager.clearLocal();
          renderLeaderboard();
        }
      });
    }

    if (tryAgainBtn) {
      tryAgainBtn.addEventListener("click", restartGame);
    }

    if (saveBtn) {
      saveBtn.addEventListener("click", handleSave);
    }
    if (nameInput) {
      nameInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          handleSave(event);
        }
      });
    }

    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {
        closeLeaderboard();
      }
    });

    window.openLeaderboard = (options) => openLeaderboard(options);
    openLeaderboardRef = openLeaderboard;
  }

  function setupGameOverListener() {
    const view = document.getElementById("view-2048");
    if (!view) return;

    view.addEventListener("game:over", (event) => {
      const score = Number(event?.detail?.score) || 0;
      const turns = Number(event?.detail?.stats?.turns) || 0;
      const undos = Number(event?.detail?.stats?.undos) || 0;
      pendingScore = { score, turns, undos, date: Date.now() };
      const qualifies = true; // Always allow name entry on game over
      if (openLeaderboardRef) {
        openLeaderboardRef({ showEntryForm: qualifies, score, turns, undos, mode: "gameover" });
      }
    });
  }

  document.addEventListener("DOMContentLoaded", () => {
    if (window.firebaseConfig && window.FirebaseManager && !window.FirebaseManager.enabled) {
      window.FirebaseManager.configure(window.firebaseConfig);
    }
    setupLeaderboard();
    setupSettingsOverlay();
    setupViews();
    setupGameOverListener();
    setupNav();
    setupGameLaunchers();
    setupMatch3Stub();
    setupPicrossStub();

    const cityScene = setupCityScene();
    if (cityScene) {
      cityScene.setInventory(window.EconomyManager ? window.EconomyManager.getInventory() : { items: {} });
    }

    loadShopCatalog().then(() => {
      if (cityScene) {
        cityScene.setCatalog(state.cityItems);
      }
    });

    bindEconomyEvents(cityScene);
    
    // Auto-launch 2048 if active view is 2048 (default)
    const startView = document.querySelector(".nav-button.active")?.dataset.view || "2048";
    showView(startView);
  });
})();
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/body/library/body_tex.json">
{"imagePath":"body_tex.png","width":1024,"SubTexture":[{"height":10,"y":994,"width":10,"name":"blank","x":444},{"height":472,"y":1,"width":295,"name":"body/a_arm_L","x":720},{"height":1013,"y":1,"width":179,"name":"body/a_leg_L","x":263},{"height":555,"y":1,"width":274,"name":"body/a_body","x":444},{"height":930,"y":1,"width":260,"name":"body/a_leg_R","x":1},{"height":517,"y":475,"width":215,"name":"body/a_arm_R","x":720},{"height":238,"y":558,"width":202,"name":"body/a_head","x":444},{"height":117,"y":798,"width":141,"name":"face/10202001","x":444}],"name":"body","height":1024}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2010600a/library/2010600a_1_tex.json">
{"SubTexture":[{"width":291,"y":1,"height":874,"name":"hair/2010600a_1","x":1}],"name":"2010600a_1","imagePath":"2010600a_1_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2010600a/library/2010600a_tex.json">
{"SubTexture":[{"width":528,"y":1,"height":851,"name":"hair/2010600a","x":1}],"name":"2010600a","imagePath":"2010600a_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20208003/library/20208003_1_tex.json">
{"SubTexture":[{"width":230,"y":1,"height":470,"name":"cloak/20208003_1","x":1}],"name":"20208003_1","imagePath":"20208003_1_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20208003/library/20208003_2_tex.json">
{"SubTexture":[{"width":250,"y":1,"height":367,"name":"cloak/20208003_2","x":1}],"name":"20208003_2","imagePath":"20208003_2_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20208003/library/20208003_3_tex.json">
{"SubTexture":[{"width":517,"y":1,"height":1259,"name":"cloak/20208003_3","x":1}],"name":"20208003_3","imagePath":"20208003_3_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20208003/library/20208003_tex.json">
{"SubTexture":[{"width":306,"y":1,"height":219,"name":"cloak/20208003","x":1}],"name":"20208003","imagePath":"20208003_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20208003/library/20405006_tex.json">
{"SubTexture":[{"width":210,"y":1,"height":409,"name":"cloak/20405006","x":1}],"name":"20405006","imagePath":"20405006_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20509005/library/20509005_tex.json">
{"SubTexture":[{"width":790,"y":1,"height":994,"name":"dress/20509005","x":1}],"name":"20509005","imagePath":"20509005_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20703016/library/20703016_1_tex.json">
{"SubTexture":[{"width":151,"y":1,"height":217,"name":"shoe/20703016_1","x":1}],"name":"20703016_1","imagePath":"20703016_1_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/20703016/library/20703016_tex.json">
{"SubTexture":[{"width":183,"y":1,"height":238,"name":"shoe/20703016","x":1}],"name":"20703016","imagePath":"20703016_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080100e/library/2080100c_tex.json">
{"SubTexture":[{"width":195,"y":1,"height":194,"name":"hat/2080100c","x":1}],"name":"2080100c","imagePath":"2080100c_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080100e/library/2080100e_1_tex.json">
{"SubTexture":[{"width":140,"y":1,"height":152,"name":"headwear/2080100e_1","x":1}],"name":"2080100e_1","imagePath":"2080100e_1_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080100e/library/2080100e_tex.json">
{"SubTexture":[{"width":181,"y":1,"height":160,"name":"headwear/2080100e","x":1}],"name":"2080100e","imagePath":"2080100e_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080100e/library/20803005_tex.json">
{"SubTexture":[{"width":16,"y":1,"height":26,"name":"earring/20803005","x":1}],"name":"20803005","imagePath":"20803005_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080500b/library/2080500b_1_tex.json">
{"SubTexture":[{"width":207,"y":1,"height":240,"name":"glove/2080500b_1","x":1}],"name":"2080500b_1","imagePath":"2080500b_1_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit1/2080500b/library/2080500b_tex.json">
{"width":162,"SubTexture":[{"width":159,"y":1,"height":323,"name":"glove/2080500b","x":1}],"height":326,"name":"2080500b","imagePath":"2080500b_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20106010/library/20106010_1_tex.json">
{"SubTexture":[{"width":226,"y":1,"height":260,"name":"hair/20106010_1","x":1}],"name":"20106010_1","imagePath":"20106010_1_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20106010/library/20106010_tex.json">
{"SubTexture":[{"width":515,"y":1,"height":750,"name":"hair/20106010","x":1}],"name":"20106010","imagePath":"20106010_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20208006/library/20208006_1_tex.json">
{"SubTexture":[{"width":507,"y":1,"height":775,"name":"cloak/20208006_1","x":1}],"name":"20208006_1","imagePath":"20208006_1_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20208006/library/20208006_2_tex.json">
{"SubTexture":[{"width":398,"y":1,"height":782,"name":"cloak/20208006_2","x":1}],"name":"20208006_2","imagePath":"20208006_2_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20208006/library/20208006_3_tex.json">
{"SubTexture":[{"width":1032,"y":1,"height":855,"name":"cloak/20208006_3","x":1}],"name":"20208006_3","imagePath":"20208006_3_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20208006/library/20208006_tex.json">
{"SubTexture":[{"width":371,"y":1,"height":1033,"name":"cloak/20208006","x":1}],"name":"20208006","imagePath":"20208006_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20208006/library/2040600b_tex.json">
{"SubTexture":[{"width":262,"y":1,"height":936,"name":"coat/2040600b","x":1}],"name":"2040600b","imagePath":"2040600b_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20509007/library/20509007_tex.json">
{"SubTexture":[{"width":899,"y":1,"height":1009,"name":"dress/20509007","x":1}],"name":"20509007","imagePath":"20509007_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20703020/library/20703020_1_tex.json">
{"SubTexture":[{"width":79,"y":1,"height":132,"name":"shoe/20703020_1","x":1}],"name":"20703020_1","imagePath":"20703020_1_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20703020/library/20703020_tex.json">
{"SubTexture":[{"width":92,"y":1,"height":138,"name":"shoe/20703020","x":1}],"name":"20703020","imagePath":"20703020_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/20801015/library/20801015_tex.json">
{"SubTexture":[{"width":243,"y":1,"height":251,"name":"headwear/20801015","x":1}],"name":"20801015","imagePath":"20801015_tex.png"}
</file>

<file path="assets_char/DragonBones Demos master DragonBones Pro-Demos_you_xin_new/suit2/2080b003/library/2080b003_tex.json">
{"SubTexture":[{"width":810,"y":1,"height":940,"name":"streamer/2080b003","x":1}],"name":"2080b003","imagePath":"2080b003_tex.png"}
</file>

<file path="assets/city/svg/building_large.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="256" height="256" viewBox="0 0 256 256">
  <polygon points="128 20 220 74 128 128 36 74" fill="#f1d2a9"/>
  <polygon points="36 74 128 128 128 232 36 178" fill="#caa173"/>
  <polygon points="220 74 128 128 128 232 220 178" fill="#b98d5e"/>
  <rect x="88" y="144" width="80" height="60" fill="#f7efe3" opacity="0.6"/>
</svg>
</file>

<file path="assets/city/svg/building_medium.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="256" height="256" viewBox="0 0 256 256">
  <polygon points="128 28 220 78 128 128 36 78" fill="#f1d2a9"/>
  <polygon points="36 78 128 128 128 216 36 166" fill="#caa173"/>
  <polygon points="220 78 128 128 128 216 220 166" fill="#b98d5e"/>
  <rect x="94" y="136" width="68" height="40" fill="#f7efe3" opacity="0.6"/>
</svg>
</file>

<file path="assets/city/svg/building_small.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="256" height="256" viewBox="0 0 256 256">
  <polygon points="128 36 220 82 128 128 36 82" fill="#f1d2a9"/>
  <polygon points="36 82 128 128 128 192 36 146" fill="#caa173"/>
  <polygon points="220 82 128 128 128 192 220 146" fill="#b98d5e"/>
</svg>
</file>

<file path="assets/city/svg/fountain.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="256" height="256" viewBox="0 0 256 256">
  <polygon points="128 40 220 88 128 136 36 88" fill="#d9dee6"/>
  <polygon points="36 88 128 136 128 208 36 160" fill="#b7c0cb"/>
  <polygon points="220 88 128 136 128 208 220 160" fill="#a7b3c0"/>
  <ellipse cx="128" cy="116" rx="44" ry="24" fill="#7dc8f0"/>
  <ellipse cx="128" cy="116" rx="24" ry="12" fill="#a7e1ff"/>
</svg>
</file>

<file path="assets/city/svg/grass.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="256" height="128" viewBox="0 0 256 128">
  <polygon points="128 0 256 64 128 128 0 64" fill="#8fd18a"/>
  <polygon points="128 8 248 64 128 120 8 64" fill="#a9e3a4" opacity="0.75"/>
</svg>
</file>

<file path="assets/city/svg/house.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="256" height="256" viewBox="0 0 256 256">
  <polygon points="128 24 220 72 128 120 36 72" fill="#f0d9b5"/>
  <polygon points="36 72 128 120 128 196 36 148" fill="#c7a779"/>
  <polygon points="220 72 128 120 128 196 220 148" fill="#b89466"/>
  <polygon points="128 8 236 64 128 120 20 64" fill="#c95a55"/>
  <polygon points="128 16 220 64 128 112 36 64" fill="#d56e6a"/>
</svg>
</file>

<file path="assets/city/svg/plaza.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="256" height="128" viewBox="0 0 256 128">
  <polygon points="128 0 256 64 128 128 0 64" fill="#d1d7df"/>
  <polygon points="128 10 246 64 128 118 10 64" fill="#e7ebf0" opacity="0.85"/>
</svg>
</file>

<file path="assets/city/svg/road_center.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="256" height="128" viewBox="0 0 256 128">
  <polygon points="128 0 256 64 128 128 0 64" fill="#8fd18a"/>
  <polygon points="128 10 246 64 128 118 10 64" fill="#a9e3a4" opacity="0.7"/>
  <polygon points="128 10 170 32 170 96 128 118 86 96 86 32" fill="#6a7076"/>
  <polygon points="128 18 162 36 162 92 128 110 94 92 94 36" fill="#7f868d"/>
  <polygon points="48 64 128 104 208 64 128 24" fill="#6a7076"/>
  <polygon points="62 64 128 96 194 64 128 32" fill="#7f868d"/>
</svg>
</file>

<file path="assets/city/svg/road_corner.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="256" height="128" viewBox="0 0 256 128">
  <polygon points="128 0 256 64 128 128 0 64" fill="#8fd18a"/>
  <polygon points="128 10 246 64 128 118 10 64" fill="#a9e3a4" opacity="0.7"/>
  <polygon points="128 10 170 32 170 96 128 118 86 96 86 32" fill="#6a7076"/>
  <polygon points="128 18 162 36 162 92 128 110 94 92 94 36" fill="#7f868d"/>
  <polygon points="128 24 170 46 144 62 102 40" fill="#6a7076"/>
</svg>
</file>

<file path="assets/city/svg/road.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="256" height="128" viewBox="0 0 256 128">
  <polygon points="128 0 256 64 128 128 0 64" fill="#8fd18a"/>
  <polygon points="128 10 246 64 128 118 10 64" fill="#a9e3a4" opacity="0.7"/>
  <polygon points="128 10 170 32 170 96 128 118 86 96 86 32" fill="#6a7076"/>
  <polygon points="128 18 162 36 162 92 128 110 94 92 94 36" fill="#7f868d"/>
</svg>
</file>

<file path="assets/city/svg/shop.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="256" height="256" viewBox="0 0 256 256">
  <polygon points="128 28 220 76 128 124 36 76" fill="#f4efe5"/>
  <polygon points="36 76 128 124 128 204 36 156" fill="#d5c7b4"/>
  <polygon points="220 76 128 124 128 204 220 156" fill="#c3b19a"/>
  <polygon points="40 84 216 84 216 112 40 112" fill="#e16666"/>
  <polygon points="60 92 196 92 196 104 60 104" fill="#f4f4f4"/>
</svg>
</file>

<file path="assets/city/svg/water.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="256" height="128" viewBox="0 0 256 128">
  <polygon points="128 0 256 64 128 128 0 64" fill="#6bb6e8"/>
  <polygon points="128 10 246 64 128 118 10 64" fill="#8ecbf2" opacity="0.8"/>
</svg>
</file>

<file path="assets/kenney_isometric-city/Donate.url">
[InternetShortcut]
URL=http://donate.kenney.nl/
</file>

<file path="assets/kenney_isometric-city/Facebook.url">
[InternetShortcut]
URL=https://www.facebook.com/KenneyNL
</file>

<file path="assets/kenney_isometric-city/License.txt">
###############################################################################


	Isometric City
	by Kenney Vleugels for Kenney (www.kenney.nl)

			------------------------------

	License (Creative Commons Zero, CC0)
	http://creativecommons.org/publicdomain/zero/1.0/

	You may use these graphics in personal and commercial projects.
	Credit (Kenney or www.kenney.nl) would be nice but is not mandatory.

			------------------------------

	Donate:   http://donate.kenney.nl/
	Request:  http://request.kenney.nl/


###############################################################################
</file>

<file path="assets/kenney_isometric-city/Spritesheet/cityDetails_sheet.xml">
<TextureAtlas imagePath="sheet.png">
	<SubTexture name="cityDetails_000.png" x="125" y="64" width="22" height="37"/>
	<SubTexture name="cityDetails_001.png" x="71" y="45" width="32" height="32"/>
	<SubTexture name="cityDetails_002.png" x="71" y="77" width="32" height="32"/>
	<SubTexture name="cityDetails_003.png" x="103" y="32" width="32" height="32"/>
	<SubTexture name="cityDetails_004.png" x="103" y="0" width="32" height="32"/>
	<SubTexture name="cityDetails_005.png" x="147" y="46" width="22" height="46"/>
	<SubTexture name="cityDetails_006.png" x="135" y="0" width="22" height="46"/>
	<SubTexture name="cityDetails_007.png" x="103" y="64" width="22" height="37"/>
	<SubTexture name="cityDetails_008.png" x="0" y="64" width="71" height="63"/>
	<SubTexture name="cityDetails_009.png" x="0" y="0" width="71" height="64"/>
	<SubTexture name="cityDetails_010.png" x="71" y="0" width="32" height="45"/>
</TextureAtlas>
</file>

<file path="assets/kenney_isometric-city/Spritesheet/cityTiles_sheet.xml">
<TextureAtlas imagePath="sheet.png">
	<SubTexture name="cityTiles_000.png" x="398" y="116" width="132" height="104"/>
	<SubTexture name="cityTiles_001.png" x="794" y="737" width="132" height="101"/>
	<SubTexture name="cityTiles_002.png" x="794" y="636" width="132" height="101"/>
	<SubTexture name="cityTiles_003.png" x="794" y="535" width="132" height="101"/>
	<SubTexture name="cityTiles_004.png" x="794" y="407" width="132" height="128"/>
	<SubTexture name="cityTiles_005.png" x="794" y="306" width="132" height="101"/>
	<SubTexture name="cityTiles_006.png" x="794" y="202" width="132" height="104"/>
	<SubTexture name="cityTiles_007.png" x="794" y="101" width="132" height="101"/>
	<SubTexture name="cityTiles_008.png" x="133" y="1208" width="133" height="101"/>
	<SubTexture name="cityTiles_009.png" x="793" y="1929" width="132" height="101"/>
	<SubTexture name="cityTiles_010.png" x="793" y="1828" width="132" height="101"/>
	<SubTexture name="cityTiles_011.png" x="793" y="1700" width="132" height="128"/>
	<SubTexture name="cityTiles_012.png" x="793" y="1572" width="132" height="128"/>
	<SubTexture name="cityTiles_013.png" x="0" y="101" width="133" height="133"/>
	<SubTexture name="cityTiles_014.png" x="793" y="1370" width="132" height="101"/>
	<SubTexture name="cityTiles_015.png" x="793" y="1269" width="132" height="101"/>
	<SubTexture name="cityTiles_016.png" x="793" y="1168" width="132" height="101"/>
	<SubTexture name="cityTiles_017.png" x="662" y="1067" width="132" height="101"/>
	<SubTexture name="cityTiles_018.png" x="0" y="234" width="133" height="133"/>
	<SubTexture name="cityTiles_019.png" x="0" y="367" width="133" height="101"/>
	<SubTexture name="cityTiles_020.png" x="662" y="766" width="132" height="101"/>
	<SubTexture name="cityTiles_021.png" x="662" y="665" width="132" height="101"/>
	<SubTexture name="cityTiles_022.png" x="662" y="564" width="132" height="101"/>
	<SubTexture name="cityTiles_023.png" x="662" y="436" width="132" height="128"/>
	<SubTexture name="cityTiles_024.png" x="662" y="303" width="132" height="133"/>
	<SubTexture name="cityTiles_025.png" x="0" y="569" width="133" height="101"/>
	<SubTexture name="cityTiles_026.png" x="0" y="769" width="133" height="133"/>
	<SubTexture name="cityTiles_027.png" x="662" y="0" width="132" height="101"/>
	<SubTexture name="cityTiles_028.png" x="661" y="1932" width="132" height="101"/>
	<SubTexture name="cityTiles_029.png" x="661" y="1831" width="132" height="101"/>
	<SubTexture name="cityTiles_030.png" x="661" y="1730" width="132" height="101"/>
	<SubTexture name="cityTiles_031.png" x="661" y="1597" width="132" height="133"/>
	<SubTexture name="cityTiles_032.png" x="0" y="902" width="133" height="101"/>
	<SubTexture name="cityTiles_033.png" x="0" y="1003" width="133" height="133"/>
	<SubTexture name="cityTiles_034.png" x="661" y="1256" width="132" height="127"/>
	<SubTexture name="cityTiles_035.png" x="530" y="1155" width="132" height="101"/>
	<SubTexture name="cityTiles_036.png" x="530" y="1032" width="132" height="123"/>
	<SubTexture name="cityTiles_037.png" x="530" y="931" width="132" height="101"/>
	<SubTexture name="cityTiles_038.png" x="530" y="830" width="132" height="101"/>
	<SubTexture name="cityTiles_039.png" x="530" y="729" width="132" height="101"/>
	<SubTexture name="cityTiles_040.png" x="0" y="1237" width="133" height="101"/>
	<SubTexture name="cityTiles_041.png" x="0" y="1843" width="133" height="127"/>
	<SubTexture name="cityTiles_042.png" x="530" y="426" width="132" height="101"/>
	<SubTexture name="cityTiles_043.png" x="530" y="325" width="132" height="101"/>
	<SubTexture name="cityTiles_044.png" x="530" y="202" width="132" height="123"/>
	<SubTexture name="cityTiles_045.png" x="530" y="101" width="132" height="101"/>
	<SubTexture name="cityTiles_046.png" x="530" y="0" width="132" height="101"/>
	<SubTexture name="cityTiles_047.png" x="0" y="1439" width="133" height="101"/>
	<SubTexture name="cityTiles_048.png" x="0" y="1742" width="133" height="101"/>
	<SubTexture name="cityTiles_049.png" x="529" y="1722" width="132" height="101"/>
	<SubTexture name="cityTiles_050.png" x="529" y="1621" width="132" height="101"/>
	<SubTexture name="cityTiles_051.png" x="529" y="1520" width="132" height="101"/>
	<SubTexture name="cityTiles_052.png" x="529" y="1419" width="132" height="101"/>
	<SubTexture name="cityTiles_053.png" x="529" y="1318" width="132" height="101"/>
	<SubTexture name="cityTiles_054.png" x="398" y="1217" width="132" height="101"/>
	<SubTexture name="cityTiles_055.png" x="133" y="604" width="133" height="101"/>
	<SubTexture name="cityTiles_056.png" x="133" y="1006" width="133" height="101"/>
	<SubTexture name="cityTiles_057.png" x="398" y="888" width="132" height="115"/>
	<SubTexture name="cityTiles_058.png" x="398" y="757" width="132" height="131"/>
	<SubTexture name="cityTiles_059.png" x="398" y="656" width="132" height="101"/>
	<SubTexture name="cityTiles_060.png" x="398" y="555" width="132" height="101"/>
	<SubTexture name="cityTiles_061.png" x="398" y="454" width="132" height="101"/>
	<SubTexture name="cityTiles_062.png" x="133" y="1309" width="133" height="101"/>
	<SubTexture name="cityTiles_063.png" x="133" y="1107" width="133" height="101"/>
	<SubTexture name="cityTiles_064.png" x="794" y="838" width="132" height="101"/>
	<SubTexture name="cityTiles_065.png" x="398" y="0" width="132" height="116"/>
	<SubTexture name="cityTiles_066.png" x="397" y="1916" width="132" height="101"/>
	<SubTexture name="cityTiles_067.png" x="397" y="1803" width="132" height="113"/>
	<SubTexture name="cityTiles_068.png" x="794" y="0" width="132" height="101"/>
	<SubTexture name="cityTiles_069.png" x="793" y="1471" width="132" height="101"/>
	<SubTexture name="cityTiles_070.png" x="0" y="0" width="133" height="101"/>
	<SubTexture name="cityTiles_071.png" x="0" y="468" width="133" height="101"/>
	<SubTexture name="cityTiles_072.png" x="662" y="968" width="132" height="99"/>
	<SubTexture name="cityTiles_073.png" x="662" y="101" width="132" height="101"/>
	<SubTexture name="cityTiles_074.png" x="662" y="202" width="132" height="101"/>
	<SubTexture name="cityTiles_075.png" x="661" y="1383" width="132" height="113"/>
	<SubTexture name="cityTiles_076.png" x="661" y="1496" width="132" height="101"/>
	<SubTexture name="cityTiles_077.png" x="133" y="705" width="133" height="101"/>
	<SubTexture name="cityTiles_078.png" x="0" y="1338" width="133" height="101"/>
	<SubTexture name="cityTiles_079.png" x="530" y="628" width="132" height="101"/>
	<SubTexture name="cityTiles_080.png" x="266" y="436" width="132" height="99"/>
	<SubTexture name="cityTiles_081.png" x="529" y="1924" width="132" height="101"/>
	<SubTexture name="cityTiles_082.png" x="398" y="1116" width="132" height="101"/>
	<SubTexture name="cityTiles_083.png" x="398" y="1003" width="132" height="113"/>
	<SubTexture name="cityTiles_084.png" x="266" y="0" width="132" height="101"/>
	<SubTexture name="cityTiles_085.png" x="133" y="101" width="133" height="101"/>
	<SubTexture name="cityTiles_086.png" x="133" y="0" width="133" height="101"/>
	<SubTexture name="cityTiles_087.png" x="265" y="1713" width="132" height="99"/>
	<SubTexture name="cityTiles_088.png" x="397" y="1702" width="132" height="101"/>
	<SubTexture name="cityTiles_089.png" x="265" y="1511" width="132" height="101"/>
	<SubTexture name="cityTiles_090.png" x="265" y="1410" width="132" height="101"/>
	<SubTexture name="cityTiles_091.png" x="266" y="737" width="132" height="101"/>
	<SubTexture name="cityTiles_092.png" x="133" y="402" width="133" height="101"/>
	<SubTexture name="cityTiles_093.png" x="133" y="503" width="133" height="101"/>
	<SubTexture name="cityTiles_094.png" x="265" y="1812" width="132" height="99"/>
	<SubTexture name="cityTiles_095.png" x="265" y="1612" width="132" height="101"/>
	<SubTexture name="cityTiles_096.png" x="133" y="1612" width="132" height="101"/>
	<SubTexture name="cityTiles_097.png" x="133" y="1713" width="132" height="133"/>
	<SubTexture name="cityTiles_098.png" x="133" y="1410" width="132" height="101"/>
	<SubTexture name="cityTiles_099.png" x="133" y="1511" width="132" height="101"/>
	<SubTexture name="cityTiles_100.png" x="133" y="905" width="133" height="101"/>
	<SubTexture name="cityTiles_101.png" x="133" y="806" width="133" height="99"/>
	<SubTexture name="cityTiles_102.png" x="266" y="101" width="132" height="101"/>
	<SubTexture name="cityTiles_103.png" x="266" y="202" width="132" height="101"/>
	<SubTexture name="cityTiles_104.png" x="265" y="1911" width="132" height="101"/>
	<SubTexture name="cityTiles_105.png" x="133" y="1846" width="132" height="133"/>
	<SubTexture name="cityTiles_106.png" x="133" y="301" width="133" height="101"/>
	<SubTexture name="cityTiles_107.png" x="133" y="202" width="133" height="99"/>
	<SubTexture name="cityTiles_108.png" x="398" y="220" width="132" height="133"/>
	<SubTexture name="cityTiles_109.png" x="398" y="353" width="132" height="101"/>
	<SubTexture name="cityTiles_110.png" x="266" y="535" width="132" height="101"/>
	<SubTexture name="cityTiles_111.png" x="529" y="1823" width="132" height="101"/>
	<SubTexture name="cityTiles_112.png" x="0" y="1641" width="133" height="101"/>
	<SubTexture name="cityTiles_113.png" x="0" y="1540" width="133" height="101"/>
	<SubTexture name="cityTiles_114.png" x="266" y="303" width="132" height="133"/>
	<SubTexture name="cityTiles_115.png" x="266" y="636" width="132" height="101"/>
	<SubTexture name="cityTiles_116.png" x="530" y="527" width="132" height="101"/>
	<SubTexture name="cityTiles_117.png" x="0" y="1136" width="133" height="101"/>
	<SubTexture name="cityTiles_118.png" x="266" y="967" width="132" height="101"/>
	<SubTexture name="cityTiles_119.png" x="266" y="838" width="132" height="129"/>
	<SubTexture name="cityTiles_120.png" x="266" y="1169" width="132" height="101"/>
	<SubTexture name="cityTiles_121.png" x="0" y="670" width="133" height="99"/>
	<SubTexture name="cityTiles_122.png" x="266" y="1068" width="132" height="101"/>
	<SubTexture name="cityTiles_123.png" x="397" y="1371" width="132" height="129"/>
	<SubTexture name="cityTiles_124.png" x="662" y="867" width="132" height="101"/>
	<SubTexture name="cityTiles_125.png" x="266" y="1270" width="132" height="101"/>
	<SubTexture name="cityTiles_126.png" x="397" y="1601" width="132" height="101"/>
	<SubTexture name="cityTiles_127.png" x="397" y="1500" width="132" height="101"/>
</TextureAtlas>
</file>

<file path="city/src/CityScene.js">
export class CityScene {
    constructor(options) {
      this.root = options.root;
      this.palette = options.palette;
      this.hint = options.hint || null;
      this.gridSize = options.gridSize || 64;
      this.storageKey = options.storageKey || "arcadeCityLayout";
      this.mode = "place";
      this.catalog = [];
      this.catalogById = {};
      this.inventory = { items: {} };
      this.selectedItemId = null;
      this.rotation = 0;

      this.layout = { gridSize: this.gridSize, tiles: [] };
      this.tileMap = new Map();
      this.occupiedMap = new Map();
      this.groundMap = [];

      this.app = null;
      this.mapContainer = null;
      this.groundContainer = null;
      this.gridContainer = null;
      this.objectContainer = null;
      this.textures = {
        ground: {},
        building: {}
      };
      this.groundSprites = new Map();

      this.tileWidth = 64;
      this.tileHeight = 32;
      this.mapWidth = 0;
      this.mapHeight = 0;
      this.mapOriginX = 0;
      this.mapOriginY = 0;
      this.scale = this.gridSize >= 40 ? 0.5 : 1;
      this.minScale = 0.35;
      this.maxScale = 1.6;
      this.pan = { x: 0, y: 0 };
      this.drag = null;
      this.dragMoved = false;
      this.pointers = new Map();
      this.initialPinchDist = null;
      this.initialScale = 1;
      this.hasPanned = false;

      this.hoverCell = null;
      this.ghostSprite = null;

      this.assets = {
        ground: {
          grass: "assets/city/svg/grass.svg",
          road: "assets/city/svg/road.svg",
          road_center: "assets/city/svg/road_center.svg",
          road_corner: "assets/city/svg/road_corner.svg",
          water: "assets/city/svg/water.svg",
          plaza: "assets/city/svg/plaza.svg"
        },
        building: {
          house: "assets/city/svg/house.svg",
          shop: "assets/city/svg/shop.svg",
          fountain: "assets/city/svg/fountain.svg",
          building_small: "assets/city/svg/building_small.svg",
          building_medium: "assets/city/svg/building_medium.svg",
          building_large: "assets/city/svg/building_large.svg"
        }
      };

      this.loadLayout();
      this.initPromise = this.buildApp()
        .then(() => this.loadAssets())
        .then(() => {
          this.updateMetrics();
          this.buildGroundMap();
          this.renderGround();
          this.renderGridOverlay();
          this.renderPlacements();
          this.renderPalette();
          this.setHint("Place mode: choose a building and tap the map.");
          this.bindInput();
          this.centerMap();
        });

      this.handleResize = () => {
        this.updateMetrics();
        this.renderGround();
        this.renderGridOverlay();
        this.renderPlacements();
        if (!this.hasPanned) {
          this.centerMap();
        } else {
          this.applyPan();
        }
      };
      window.addEventListener("resize", this.handleResize);
    }

    buildApp() {
      if (!window.PIXI) {
        console.warn("PIXI is not available. CityScene cannot render.");
        return Promise.resolve();
      }
      this.root.innerHTML = "";
      this.app = new window.PIXI.Application();

      return this.app.init({
        backgroundAlpha: 0,
        antialias: true,
        resizeTo: this.root
      }).then(() => {
        this.app.view.classList.add("city-canvas");
        this.app.view.style.width = "100%";
        this.app.view.style.height = "100%";
        this.app.view.style.touchAction = "none";
        this.root.appendChild(this.app.view);

        this.mapContainer = new window.PIXI.Container();
        this.mapContainer.sortableChildren = true;
        this.groundContainer = new window.PIXI.Container();
        this.gridContainer = new window.PIXI.Container();
        this.objectContainer = new window.PIXI.Container();
        this.objectContainer.sortableChildren = true;

        this.mapContainer.addChild(this.groundContainer);
        this.mapContainer.addChild(this.gridContainer);
        this.mapContainer.addChild(this.objectContainer);
        this.app.stage.addChild(this.mapContainer);
      });
    }

    loadAssets() {
      if (!window.PIXI || !window.PIXI.Assets) {
        return Promise.resolve();
      }
      const urls = [
        ...Object.values(this.assets.ground),
        ...Object.values(this.assets.building)
      ];
      return window.PIXI.Assets.load(urls).then(() => {
        Object.entries(this.assets.ground).forEach(([key, url]) => {
          this.textures.ground[key] = window.PIXI.Texture.from(url);
        });
        Object.entries(this.assets.building).forEach(([key, url]) => {
          this.textures.building[key] = window.PIXI.Texture.from(url);
        });
      });
    }

    setCatalog(items) {
      this.catalog = Array.isArray(items) ? items : [];
      this.catalogById = {};
      this.catalog.forEach((item) => {
        if (item && item.id) {
          this.catalogById[item.id] = item;
        }
      });
      if (!this.selectedItemId && this.catalog.length > 0) {
        this.selectedItemId = this.catalog[0].id;
      }
      this.seedStarterLayout();
      this.renderPalette();
      this.renderPlacements();
    }

    setInventory(inventory) {
      this.inventory = inventory || { items: {} };
      this.renderPalette();
    }

    setMode(mode) {
      this.mode = mode === "erase" ? "erase" : "place";
      if (this.mode === "erase") {
        this.setHint("Erase mode: tap a building to remove it.");
      } else {
        this.setHint("Place mode: choose a building and tap the map.");
      }
      this.clearGhost();
    }

    rotateSelection(delta) {
      const next = ((this.rotation + delta) % 360 + 360) % 360;
      this.rotation = next;
      this.clearGhost();
      this.setHint(`Rotation ${this.rotation} degrees.`);
    }

    setHint(message) {
      if (!this.hint) return;
      this.hint.textContent = message;
    }

    getItemCount(itemId) {
      const items = this.inventory.items || {};
      return Number(items[itemId]) || 0;
    }

    getFootprint(item) {
      const footprint = item && item.footprint ? item.footprint : { w: 1, h: 1 };
      return {
        w: Math.max(1, Math.floor(footprint.w || 1)),
        h: Math.max(1, Math.floor(footprint.h || 1))
      };
    }

    getRotatedFootprint(footprint, rotation) {
      if ((rotation / 90) % 2 !== 0) {
        return { w: footprint.h, h: footprint.w };
      }
      return { w: footprint.w, h: footprint.h };
    }

    loadLayout() {
      try {
        const raw = localStorage.getItem(this.storageKey);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        if (parsed && Array.isArray(parsed.tiles)) {
          this.layout = parsed;
          this.gridSize = parsed.gridSize || this.gridSize;
          this.tileMap = new Map(parsed.tiles.map((tile) => [this.key(tile.x, tile.y), tile]));
          if (Array.isArray(parsed.ground)) {
            this.groundMap = parsed.ground;
          }
        }
      } catch (error) {
        // Ignore corrupted data.
      }
    }

    saveLayout() {
      this.layout.tiles = Array.from(this.tileMap.values());
      this.layout.gridSize = this.gridSize;
      this.layout.ground = this.groundMap;
      try {
        localStorage.setItem(this.storageKey, JSON.stringify(this.layout));
      } catch (error) {
        // Ignore storage errors.
      }
    }

    clearLayout() {
      if (this.tileMap.size === 0) return;
      this.clearGhost();
      this.tileMap.forEach((tile) => {
        if (window.EconomyManager) {
          window.EconomyManager.addItem(tile.id, 1, { reason: "clear" });
        }
      });
      this.tileMap.clear();
      this.saveLayout();
      this.renderPlacements();
      this.setHint("City cleared. Items returned to inventory.");
    }

    updateMetrics() {
      const style = getComputedStyle(this.root);
      const widthValue = parseFloat(style.getPropertyValue("--city-tile-width"));
      this.tileWidth = Number.isFinite(widthValue) && widthValue > 0 ? widthValue : 64;
      this.tileHeight = this.tileWidth / 2;
      this.mapWidth = this.gridSize * this.tileWidth;
      this.mapHeight = this.gridSize * this.tileHeight;
      this.mapOriginX = this.mapWidth / 2;
      this.mapOriginY = this.tileHeight / 2;
    }

    centerMap() {
      if (!this.root || !this.mapContainer) return;
      const rect = this.root.getBoundingClientRect();
      if (rect.width <= 0 || rect.height <= 0) return;
      this.pan.x = (rect.width - this.mapWidth * this.scale) / 2;
      this.pan.y = (rect.height - this.mapHeight * this.scale) / 2;
      this.applyPan();
    }

    applyPan() {
      if (!this.mapContainer) return;
      this.mapContainer.x = this.pan.x;
      this.mapContainer.y = this.pan.y;
      this.mapContainer.scale.set(this.scale);
    }

    clampScale(nextScale) {
      return Math.max(this.minScale, Math.min(this.maxScale, nextScale));
    }

    applyZoom(nextScale, center) {
      const clamped = this.clampScale(nextScale);
      if (clamped === this.scale) return;
      const worldX = (center.x - this.pan.x) / this.scale;
      const worldY = (center.y - this.pan.y) / this.scale;
      this.scale = clamped;
      this.pan.x = center.x - worldX * this.scale;
      this.pan.y = center.y - worldY * this.scale;
      this.applyPan();
    }

    getPointerPosition(event) {
      const rect = this.app.view.getBoundingClientRect();
      return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
      };
    }

    getPinchDistance() {
      const points = Array.from(this.pointers.values());
      if (points.length < 2) return 0;
      return Math.hypot(points[0].x - points[1].x, points[0].y - points[1].y);
    }

    getPinchCenter() {
      const points = Array.from(this.pointers.values());
      if (points.length < 2) return { x: 0, y: 0 };
      return {
        x: (points[0].x + points[1].x) / 2,
        y: (points[0].y + points[1].y) / 2
      };
    }

    gridToScreen(x, y) {
      const screenX = (x - y) * (this.tileWidth / 2) + this.mapOriginX;
      const screenY = (x + y) * (this.tileHeight / 2) + this.mapOriginY;
      return { x: screenX, y: screenY };
    }

    screenToGrid(screenX, screenY) {
      const dx = screenX - this.mapOriginX;
      const dy = screenY - this.mapOriginY;
      const gx = (dx / (this.tileWidth / 2) + dy / (this.tileHeight / 2)) / 2;
      const gy = (dy / (this.tileHeight / 2) - dx / (this.tileWidth / 2)) / 2;
      return { x: Math.floor(gx), y: Math.floor(gy) };
    }

    buildGroundMap() {
      if (this.groundMap.length) return;
      const size = this.gridSize;
      const quarter = Math.floor(size / 4);
      const half = Math.floor(size / 2);
      const threeQuarter = Math.floor((3 * size) / 4);
      const major = [quarter, half, threeQuarter].filter((value) => value > 0 && value < size);
      this.groundMap = [];

      for (let y = 0; y < size; y += 1) {
        const row = [];
        for (let x = 0; x < size; x += 1) {
          let type = "grass";
          row.push(type);
        }
        this.groundMap.push(row);
      }

      const rng = this.getSeededRng();
      const roadLines = new Set();
      major.forEach((value) => roadLines.add(value));
      for (let i = 0; i < 4; i += 1) {
        const extra = Math.floor(rng() * size);
        roadLines.add(extra);
      }

      for (let y = 0; y < size; y += 1) {
        for (let x = 0; x < size; x += 1) {
          if (roadLines.has(x) || roadLines.has(y)) {
            this.groundMap[y][x] = "road";
          }
        }
      }

      this.placePlazaPatch(Math.floor(size / 2), Math.floor(size / 2), 4);
      for (let i = 0; i < 2; i += 1) {
        const px = Math.floor(rng() * (size - 6)) + 3;
        const py = Math.floor(rng() * (size - 6)) + 3;
        this.placePlazaPatch(px, py, 3);
      }
    }

    seedStarterLayout() {
      if (this.tileMap.size > 0) return;
      const rng = this.getSeededRng();
      const candidates = this.collectRoadAdjacents();
      const starterItems = [
        { id: "city_townhall", fallback: { w: 4, h: 3 } },
        { id: "city_park_fountain", fallback: { w: 3, h: 3 } },
        { id: "city_bakery", fallback: { w: 3, h: 2 } },
        { id: "city_house_small", fallback: { w: 2, h: 2 } },
        { id: "city_house_small", fallback: { w: 2, h: 2 } }
      ];

      starterItems.forEach((entry) => {
        const item = this.catalogById[entry.id] || entry;
        const footprint = this.getFootprint(item);
        for (let attempt = 0; attempt < 80; attempt += 1) {
          const pick = candidates[Math.floor(rng() * candidates.length)];
          if (!pick) break;
          const rotated = this.getRotatedFootprint(footprint, 0);
          if (this.canPlaceAt(pick.x, pick.y, rotated).ok) {
            this.tileMap.set(this.key(pick.x, pick.y), {
              x: pick.x,
              y: pick.y,
              id: entry.id,
              rotation: 0,
              footprint
            });
            break;
          }
        }
      });

      this.saveLayout();
    }

    getGroundType(x, y) {
      const base = this.groundMap[y] && this.groundMap[y][x] ? this.groundMap[y][x] : "grass";
      if (this.isRoadType(base)) {
        return this.getRoadVariant(x, y);
      }
      return base;
    }

    renderGround() {
      if (!this.groundContainer) return;
      this.groundContainer.removeChildren();
      this.groundSprites.clear();

      for (let y = 0; y < this.gridSize; y += 1) {
        for (let x = 0; x < this.gridSize; x += 1) {
          const type = this.getGroundType(x, y);
          const texture = this.textures.ground[type] || this.textures.ground.grass;
          if (!texture) continue;
          const sprite = new window.PIXI.Sprite(texture);
          sprite.anchor.set(0.5);
          sprite.width = this.tileWidth;
          sprite.height = this.tileHeight;
          const position = this.gridToScreen(x, y);
          sprite.x = position.x;
          sprite.y = position.y;
          sprite.zIndex = x + y;
          this.groundContainer.addChild(sprite);
          this.groundSprites.set(this.key(x, y), sprite);
        }
      }
    }

    updateGroundTile(x, y) {
      const sprite = this.groundSprites.get(this.key(x, y));
      const type = this.getGroundType(x, y);
      const texture = this.textures.ground[type] || this.textures.ground.grass;
      if (sprite && texture) {
        sprite.texture = texture;
      }
    }

    renderGridOverlay() {
      if (!this.gridContainer) return;
      this.gridContainer.removeChildren();
      const grid = new window.PIXI.Graphics();
      grid.lineStyle(1, 0xffffff, 0.18);

      for (let y = 0; y <= this.gridSize; y += 1) {
        const start = this.gridToScreen(0, y);
        const end = this.gridToScreen(this.gridSize, y);
        grid.moveTo(start.x, start.y);
        grid.lineTo(end.x, end.y);
      }

      for (let x = 0; x <= this.gridSize; x += 1) {
        const start = this.gridToScreen(x, 0);
        const end = this.gridToScreen(x, this.gridSize);
        grid.moveTo(start.x, start.y);
        grid.lineTo(end.x, end.y);
      }

      this.gridContainer.addChild(grid);
    }

    rebuildOccupancy() {
      this.occupiedMap.clear();
      this.tileMap.forEach((tile, key) => {
        const item = this.catalogById[tile.id] || tile;
        const footprint = this.getFootprint(item);
        const rotated = this.getRotatedFootprint(footprint, tile.rotation || 0);
        for (let dy = 0; dy < rotated.h; dy += 1) {
          for (let dx = 0; dx < rotated.w; dx += 1) {
            this.occupiedMap.set(this.key(tile.x + dx, tile.y + dy), key);
          }
        }
      });
    }

    renderPlacements() {
      if (!this.objectContainer) return;
      this.rebuildOccupancy();
      this.objectContainer.removeChildren();

      this.tileMap.forEach((tile) => {
        const sprite = this.createBuildingSprite(tile, false, false);
        if (sprite) {
          this.objectContainer.addChild(sprite);
        }
      });
    }

    createBuildingSprite(tile, isGhost, blocked) {
      const item = this.catalogById[tile.id] || tile;
      const footprint = this.getFootprint(item);
      const rotated = this.getRotatedFootprint(footprint, tile.rotation || 0);
      const anchorX = tile.x + (rotated.w - 1) / 2;
      const anchorY = tile.y + (rotated.h - 1) / 2;
      const screen = this.gridToScreen(anchorX, anchorY);

      const texture = this.getBuildingTexture(item, rotated);
      if (!texture) return null;

      const sprite = new window.PIXI.Sprite(texture);
      sprite.anchor.set(0.5, 1);
      const span = rotated.w + rotated.h;
      sprite.width = this.tileWidth * (span / 2) * 1.2;
      sprite.height = this.tileHeight * (2 + Math.max(rotated.w, rotated.h) * 1.4);
      sprite.x = screen.x;
      sprite.y = screen.y;
      sprite.rotation = ((tile.rotation || 0) * Math.PI) / 180;
      sprite.alpha = isGhost ? 0.6 : 1;
      if (blocked) {
        sprite.tint = 0xff8888;
      }
      sprite.zIndex = (tile.x + tile.y + rotated.w + rotated.h) * 10;
      return sprite;
    }

    getBuildingTexture(item, footprint) {
      if (item && item.sprite) {
        const match = Object.entries(this.assets.building).find(([, url]) => url === item.sprite);
        if (match) {
          return this.textures.building[match[0]];
        }
      }
      const area = footprint.w * footprint.h;
      if (area <= 4) return this.textures.building.building_small;
      if (area <= 8) return this.textures.building.building_medium;
      return this.textures.building.building_large;
    }

    clearGhost() {
      if (this.ghostSprite && this.objectContainer) {
        this.objectContainer.removeChild(this.ghostSprite);
      }
      this.ghostSprite = null;
      this.hoverCell = null;
    }

    showGhostAt(x, y) {
      if (this.mode !== "place") return;
      if (!this.selectedItemId) return;
      const item = this.catalogById[this.selectedItemId];
      if (!item) return;
      if (this.hoverCell && this.hoverCell.x === x && this.hoverCell.y === y) return;

      this.clearGhost();
      const footprint = this.getFootprint(item);
      const rotated = this.getRotatedFootprint(footprint, this.rotation);
      const result = this.canPlaceAt(x, y, rotated);
      let ghost = null;
      if (this.isGroundItem(item)) {
        ghost = this.createGroundGhost(x, y, !result.ok);
      } else {
        const ghostTile = { x, y, id: this.selectedItemId, rotation: this.rotation };
        ghost = this.createBuildingSprite(ghostTile, true, !result.ok);
      }
      if (ghost && this.objectContainer) {
        this.ghostSprite = ghost;
        this.objectContainer.addChild(ghost);
      }
      this.hoverCell = { x, y };
    }

    canPlaceAt(x, y, rotated) {
      if (x < 0 || y < 0) return { ok: false, reason: "bounds" };
      if (x + rotated.w > this.gridSize || y + rotated.h > this.gridSize) {
        return { ok: false, reason: "bounds" };
      }
      for (let dy = 0; dy < rotated.h; dy += 1) {
        for (let dx = 0; dx < rotated.w; dx += 1) {
          const key = this.key(x + dx, y + dy);
          if (this.occupiedMap.has(key)) {
            return { ok: false, reason: "occupied" };
          }
        }
      }
      return { ok: true };
    }

    handleCellClick(x, y) {
      if (this.mode === "erase") {
        this.eraseAt(x, y);
        return;
      }
      this.placeAt(x, y);
    }

    placeAt(x, y) {
      if (!this.selectedItemId) {
        this.setHint("Select a building from your palette first.");
        return;
      }
      const item = this.catalogById[this.selectedItemId];
      if (!item) return;
      const footprint = this.getFootprint(item);
      const rotated = this.getRotatedFootprint(footprint, this.rotation);
      const result = this.canPlaceAt(x, y, rotated);
      if (!result.ok) {
        this.setHint(result.reason === "occupied" ? "That area is occupied." : "Out of bounds.");
        return;
      }
      if (this.isGroundItem(item)) {
        if (window.EconomyManager && !window.EconomyManager.removeItem(this.selectedItemId, 1, { reason: "place" })) {
          this.setHint("You do not own this tile yet.");
          return;
        }
        this.setGroundAt(x, y, item.groundType || "road");
        this.saveLayout();
        this.setHint("Tile placed.");
        return;
      }
      if (window.EconomyManager && !window.EconomyManager.removeItem(this.selectedItemId, 1, { reason: "place" })) {
        this.setHint("You do not own this building yet.");
        return;
      }
      this.tileMap.set(this.key(x, y), {
        x,
        y,
        id: this.selectedItemId,
        rotation: this.rotation,
        footprint
      });
      this.saveLayout();
      this.renderPlacements();
      this.setHint("Building placed.");
    }

    eraseAt(x, y) {
      const buildingKey = this.occupiedMap.get(this.key(x, y));
      if (!buildingKey) {
        this.setHint("Nothing to remove here.");
        return;
      }
      const tile = this.tileMap.get(buildingKey);
      if (!tile) {
        this.setHint("Nothing to remove here.");
        return;
      }
      this.tileMap.delete(buildingKey);
      if (window.EconomyManager) {
        window.EconomyManager.addItem(tile.id, 1, { reason: "erase" });
      }
      this.saveLayout();
      this.renderPlacements();
      this.setHint("Building removed.");
    }

    setGroundAt(x, y, type) {
      if (!this.groundMap[y]) {
        this.groundMap[y] = [];
      }
      this.groundMap[y][x] = type;
      this.updateGroundNeighbors(x, y);
    }

    isGroundItem(item) {
      return item && (item.type === "ground" || item.placeLayer === "ground");
    }

    createGroundGhost(x, y, blocked) {
      const type = this.getGroundType(x, y);
      const texture = this.textures.ground[type] || this.textures.ground.grass;
      if (!texture) return null;
      const sprite = new window.PIXI.Sprite(texture);
      sprite.anchor.set(0.5);
      sprite.width = this.tileWidth;
      sprite.height = this.tileHeight;
      const position = this.gridToScreen(x, y);
      sprite.x = position.x;
      sprite.y = position.y;
      sprite.alpha = 0.6;
      if (blocked) {
        sprite.tint = 0xff8888;
      }
      sprite.zIndex = 9999;
      return sprite;
    }

    bindInput() {
      if (!this.app || !this.app.view) return;
      const view = this.app.view;

      view.addEventListener("pointerdown", (event) => {
        if (event.button !== undefined && event.button !== 0) return;
        view.setPointerCapture(event.pointerId);
        const point = this.getPointerPosition(event);
        this.pointers.set(event.pointerId, point);

        if (this.pointers.size === 1) {
          this.drag = {
            pointerId: event.pointerId,
            startX: event.clientX,
            startY: event.clientY,
            panX: this.pan.x,
            panY: this.pan.y
          };
          this.dragMoved = false;
          this.root.classList.add("dragging");
        } else if (this.pointers.size === 2) {
          this.drag = null;
          this.dragMoved = true;
          this.initialPinchDist = this.getPinchDistance();
          this.initialScale = this.scale;
        }
      });

      view.addEventListener("pointermove", (event) => {
        if (!this.pointers.has(event.pointerId)) return;
        this.pointers.set(event.pointerId, this.getPointerPosition(event));

        if (this.pointers.size === 2) {
          const currentDist = this.getPinchDistance();
          if (this.initialPinchDist) {
            const nextScale = this.initialScale * (currentDist / this.initialPinchDist);
            const center = this.getPinchCenter();
            this.applyZoom(nextScale, center);
          }
          return;
        }

        if (!this.drag) return;
        const dx = event.clientX - this.drag.startX;
        const dy = event.clientY - this.drag.startY;
        if (Math.abs(dx) + Math.abs(dy) > 6) {
          this.dragMoved = true;
        }
        this.pan.x = this.drag.panX + dx;
        this.pan.y = this.drag.panY + dy;
        this.applyPan();
        if (this.dragMoved) {
          this.hasPanned = true;
        }
      });

      const endPointer = (event) => {
        if (this.pointers.has(event.pointerId)) {
          this.pointers.delete(event.pointerId);
        }
        if (this.pointers.size < 2) {
          this.initialPinchDist = null;
        }
        if (!this.dragMoved) {
          const local = this.getLocalMapPoint(event);
          const cell = this.screenToGrid(local.x, local.y);
          if (this.isValidCell(cell.x, cell.y)) {
            this.handleCellClick(cell.x, cell.y);
          }
        }
        this.drag = null;
        this.dragMoved = false;
        this.root.classList.remove("dragging");
        try {
          view.releasePointerCapture(event.pointerId);
        } catch (error) {
          // Ignore.
        }
      };

      view.addEventListener("pointerup", endPointer);
      view.addEventListener("pointercancel", endPointer);
      view.addEventListener("pointerleave", () => {
        this.clearGhost();
      });

      view.addEventListener("pointermove", (event) => {
        if (this.drag || this.pointers.size > 1) return;
        const local = this.getLocalMapPoint(event);
        const cell = this.screenToGrid(local.x, local.y);
        if (this.isValidCell(cell.x, cell.y)) {
          this.showGhostAt(cell.x, cell.y);
        } else {
          this.clearGhost();
        }
      });

      view.addEventListener(
        "wheel",
        (event) => {
          event.preventDefault();
          const center = this.getPointerPosition(event);
          const scaleChange = Math.pow(0.999, event.deltaY);
          this.applyZoom(this.scale * scaleChange, center);
          this.hasPanned = true;
        },
        { passive: false }
      );
    }

    getLocalMapPoint(event) {
      const point = this.getPointerPosition(event);
      return {
        x: (point.x - this.pan.x) / this.scale,
        y: (point.y - this.pan.y) / this.scale
      };
    }

    isValidCell(x, y) {
      return x >= 0 && y >= 0 && x < this.gridSize && y < this.gridSize;
    }

    key(x, y) {
      return `${x},${y}`;
    }

    isRoadType(type) {
      return type === "road" || type === "road_center" || type === "road_corner";
    }

    getRoadVariant(x, y) {
      const has = (nx, ny) => {
        const value = this.groundMap[ny] && this.groundMap[ny][nx];
        return this.isRoadType(value);
      };
      const north = has(x, y - 1);
      const south = has(x, y + 1);
      const west = has(x - 1, y);
      const east = has(x + 1, y);
      const count = [north, south, west, east].filter(Boolean).length;

      if (count >= 3) return "road_center";
      if ((north && south) || (east && west)) return "road";
      if ((north && east) || (east && south) || (south && west) || (west && north)) return "road_corner";
      return "road";
    }

    updateGroundNeighbors(x, y) {
      const offsets = [
        [0, 0],
        [1, 0],
        [-1, 0],
        [0, 1],
        [0, -1]
      ];
      offsets.forEach(([dx, dy]) => {
        const nx = x + dx;
        const ny = y + dy;
        if (this.isValidCell(nx, ny)) {
          this.updateGroundTile(nx, ny);
        }
      });
    }

    getSeededRng() {
      const key = this.getSeedKey();
      let seed = 0;
      try {
        const existing = localStorage.getItem(key);
        if (existing) {
          seed = Number(existing);
        } else {
          seed = this.setSeed();
        }
      } catch (error) {
        seed = 13371337;
      }
      let t = seed >>> 0;
      return () => {
        t += 0x6d2b79f5;
        let r = Math.imul(t ^ (t >>> 15), 1 | t);
        r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
        return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
      };
    }

    collectRoadAdjacents() {
      const results = [];
      for (let y = 1; y < this.gridSize - 1; y += 1) {
        for (let x = 1; x < this.gridSize - 1; x += 1) {
          if (this.isRoadType(this.getGroundType(x, y))) {
            const neighbors = [
              [x + 1, y],
              [x - 1, y],
              [x, y + 1],
              [x, y - 1]
            ];
            neighbors.forEach(([nx, ny]) => {
              if (!this.isRoadType(this.getGroundType(nx, ny))) {
                results.push({ x: nx, y: ny });
              }
            });
          }
        }
      }
      return results.length ? results : [{ x: Math.floor(this.gridSize / 2), y: Math.floor(this.gridSize / 2) }];
    }

    placePlazaPatch(centerX, centerY, size) {
      const half = Math.floor(size / 2);
      for (let y = centerY - half; y <= centerY + half; y += 1) {
        for (let x = centerX - half; x <= centerX + half; x += 1) {
          if (this.isValidCell(x, y)) {
            this.groundMap[y][x] = "plaza";
          }
        }
      }
    }

    renderPalette() {
      if (!this.palette) return;
      this.palette.innerHTML = "";

      if (!this.catalog.length) {
        const empty = document.createElement("div");
        empty.className = "city-empty";
        empty.textContent = "Buy city items in the Shop to unlock this palette.";
        this.palette.appendChild(empty);
        return;
      }

      this.catalog.forEach((item) => {
        const button = document.createElement("button");
        button.type = "button";
        button.className = "city-item";
        if (item.id === this.selectedItemId) {
          button.classList.add("active");
        }

        const footprint = this.getFootprint(item);
        const preview = document.createElement("span");
        preview.className = "city-item-preview";
        if (item.sprite) {
          preview.style.backgroundImage = `url("${item.sprite}")`;
        }

        const details = document.createElement("div");
        details.className = "city-item-details";

        const name = document.createElement("div");
        name.className = "city-item-name";
        name.textContent = item.name || item.id;

        const size = document.createElement("div");
        size.className = "city-item-size ui-label";
        size.textContent = `${footprint.w}x${footprint.h}`;

        details.appendChild(name);
        details.appendChild(size);

        const count = document.createElement("span");
        count.className = "city-item-count";
        const available = this.getItemCount(item.id);
        count.textContent = `x${available}`;
        if (available <= 0) {
          button.classList.add("locked");
        }

        button.appendChild(preview);
        button.appendChild(details);
        button.appendChild(count);
        button.addEventListener("click", () => {
          this.selectedItemId = item.id;
          this.renderPalette();
          this.clearGhost();
          this.setHint("Place mode: tap the map to place this building.");
        });

        this.palette.appendChild(button);
      });
    }

    onShow() {
      window.requestAnimationFrame(() => {
        this.updateMetrics();
        this.renderGround();
        this.renderGridOverlay();
        this.renderPlacements();
        if (!this.hasPanned) {
          this.centerMap();
        } else {
          this.applyPan();
        }
      });
    }

    getSeedKey() {
      return `${this.storageKey}:seed`;
    }

    setSeed(nextSeed) {
      const seed = Number.isFinite(nextSeed) ? Math.floor(nextSeed) : Math.floor(Math.random() * 2 ** 31);
      try {
        localStorage.setItem(this.getSeedKey(), String(seed));
      } catch (error) {
        // Ignore seed storage errors.
      }
      return seed;
    }

    regenerateStarterCity() {
      this.setSeed();
      this.tileMap.clear();
      this.groundMap = [];
      this.buildGroundMap();
      this.renderGround();
      this.renderGridOverlay();
      this.seedStarterLayout();
      this.renderPlacements();
      this.saveLayout();
      this.setHint("Starter city regenerated.");
    }
  }
</file>

<file path="city/src/MinigameBase.js">
export class MinigameBase {
    constructor(gameId) {
      this.gameId = gameId;
      this.active = false;
    }

    init() {
      this.active = true;
    }

    pause() {
      this.active = false;
    }

    resume() {
      this.active = true;
    }

    destroy() {
      this.active = false;
    }
  }
</file>

<file path="core.js">
(function () {
  "use strict";

  const EconomyConfig = {
    games: {
      "2048": { scorePerCoin: 10 },
      "match3": { scorePerCoin: 200 },
      "picross": { completionCoins: 5 }
    }
  };

  class EventBus {
    constructor() {
      this.listeners = new Map();
    }

    on(eventName, handler) {
      if (!this.listeners.has(eventName)) {
        this.listeners.set(eventName, new Set());
      }
      const handlers = this.listeners.get(eventName);
      handlers.add(handler);
      return () => this.off(eventName, handler);
    }

    off(eventName, handler) {
      const handlers = this.listeners.get(eventName);
      if (!handlers) return;
      handlers.delete(handler);
      if (handlers.size === 0) {
        this.listeners.delete(eventName);
      }
    }

    emit(eventName, payload) {
      const handlers = this.listeners.get(eventName);
      if (!handlers) return;
      handlers.forEach((handler) => handler(payload));
    }
  }

  class EconomyManager {
    constructor(bus, options = {}) {
      this.bus = bus;
      this.coinKey = options.coinKey || "arcadeCityCoins";
      this.progressKey = options.progressKey || "arcadeCityRunProgress";
      this.inventoryKey = options.inventoryKey || "arcadeCityInventory";
      this.config = options.config || EconomyConfig;
      this.coins = this.loadNumber(this.coinKey, 0);
      this.progress = this.loadJson(this.progressKey, {});
      this.inventory = this.loadJson(this.inventoryKey, { items: {} });
      if (!this.inventory || typeof this.inventory !== "object") {
        this.inventory = { items: {} };
      }
      if (!this.inventory.items || typeof this.inventory.items !== "object") {
        this.inventory.items = {};
      }
    }

    loadNumber(key, fallback) {
      try {
        const raw = localStorage.getItem(key);
        const value = Number(raw);
        return Number.isFinite(value) ? value : fallback;
      } catch (error) {
        return fallback;
      }
    }

    saveNumber(key, value) {
      try {
        localStorage.setItem(key, String(value));
      } catch (error) {
        // Ignore storage errors in private mode.
      }
    }

    loadJson(key, fallback) {
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return fallback;
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === "object" ? parsed : fallback;
      } catch (error) {
        return fallback;
      }
    }

    saveJson(key, value) {
      try {
        localStorage.setItem(key, JSON.stringify(value));
      } catch (error) {
        // Ignore storage errors in private mode.
      }
    }

    getCoins() {
      return this.coins;
    }

    getInventory() {
      return JSON.parse(JSON.stringify(this.inventory));
    }

    getItemCount(itemId) {
      if (!itemId) return 0;
      const items = this.inventory.items || {};
      return Number(items[itemId]) || 0;
    }

    setCoins(value, meta) {
      const next = Math.max(0, Math.floor(value));
      const delta = next - this.coins;
      if (delta === 0) return;
      this.coins = next;
      this.saveNumber(this.coinKey, this.coins);
      if (this.bus) {
        this.bus.emit("economy:changed", { coins: this.coins, delta, meta });
      }
    }

    spendCoins(amount, meta) {
      const delta = Math.floor(amount);
      if (!Number.isFinite(delta) || delta <= 0) return false;
      if (this.coins < delta) return false;
      this.setCoins(this.coins - delta, meta);
      return true;
    }

    addCoins(amount, meta) {
      const delta = Math.floor(amount);
      if (!Number.isFinite(delta) || delta <= 0) return;
      this.setCoins(this.coins + delta, meta);
    }

    addItem(itemId, count = 1, meta) {
      if (!itemId) return;
      const amount = Math.floor(count);
      if (!Number.isFinite(amount) || amount <= 0) return;
      const items = this.inventory.items || {};
      items[itemId] = (Number(items[itemId]) || 0) + amount;
      this.inventory.items = items;
      this.saveJson(this.inventoryKey, this.inventory);
      if (this.bus) {
        this.bus.emit("economy:inventory", { itemId, count: amount, total: items[itemId], meta });
      }
    }

    removeItem(itemId, count = 1, meta) {
      if (!itemId) return false;
      const amount = Math.floor(count);
      if (!Number.isFinite(amount) || amount <= 0) return false;
      const items = this.inventory.items || {};
      const current = Number(items[itemId]) || 0;
      if (current < amount) return false;
      const next = current - amount;
      if (next > 0) {
        items[itemId] = next;
      } else {
        delete items[itemId];
      }
      this.inventory.items = items;
      this.saveJson(this.inventoryKey, this.inventory);
      if (this.bus) {
        this.bus.emit("economy:inventory", { itemId, count: -amount, total: next, meta });
      }
      return true;
    }

    purchaseItem(item) {
      if (!item || !item.id) return { ok: false, reason: "invalid-item" };
      const price = Math.floor(item.price);
      if (!Number.isFinite(price) || price <= 0) return { ok: false, reason: "invalid-price" };
      const canSpend = this.spendCoins(price, { reason: "purchase", itemId: item.id });
      if (!canSpend) return { ok: false, reason: "insufficient-coins" };
      this.addItem(item.id, 1, { reason: "purchase", itemId: item.id });
      return { ok: true };
    }

    ensureRun(gameId) {
      if (!gameId) return null;
      const entry = this.progress[gameId];
      if (entry && entry.runId) {
        return entry.runId;
      }
      return this.startRun(gameId);
    }

    startRun(gameId) {
      if (!gameId) return null;
      const runId = this.generateRunId();
      this.progress[gameId] = { runId, score: 0 };
      this.saveJson(this.progressKey, this.progress);
      if (this.bus) {
        this.bus.emit("economy:run", { gameId, runId });
      }
      return runId;
    }

    awardFromScore(gameId, score) {
      if (!gameId) return;
      const rule = this.getGameRule(gameId);
      if (!rule || !rule.scorePerCoin) return;
      const entry = this.progress[gameId] || { runId: this.generateRunId(), score: 0 };
      const nextScore = Math.max(entry.score || 0, Math.floor(score || 0));
      if (nextScore <= (entry.score || 0)) {
        this.progress[gameId] = entry;
        return;
      }
      const prevCoins = Math.floor((entry.score || 0) / rule.scorePerCoin);
      const nextCoins = Math.floor(nextScore / rule.scorePerCoin);
      const delta = nextCoins - prevCoins;
      entry.score = nextScore;
      this.progress[gameId] = entry;
      this.saveJson(this.progressKey, this.progress);
      if (delta > 0) {
        this.addCoins(delta, { source: gameId, reason: "score", score: nextScore });
      }
    }

    awardCompletion(gameId, meta) {
      if (!gameId) return;
      const rule = this.getGameRule(gameId);
      if (!rule || !Number.isFinite(rule.completionCoins) || rule.completionCoins <= 0) {
        return;
      }
      this.addCoins(rule.completionCoins, { source: gameId, reason: "completion", meta });
    }

    getGameRule(gameId) {
      const config = this.config || {};
      const gameRules = config.games || {};
      const rule = gameRules[gameId];
      return rule || null;
    }

    generateRunId() {
      return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 10)}`;
    }
  }

  const appBus = new EventBus();
  const economyManager = new EconomyManager(appBus, { config: EconomyConfig });

  function bindCurrencyDisplay() {
    const display = document.getElementById("currency-balance");
    if (!display) return;
    const update = (coins) => {
      const value = Number.isFinite(coins) ? coins : 0;
      const valueEl = display.querySelector(".score-value");
      if (valueEl) {
        valueEl.textContent = value.toLocaleString();
      } else {
        display.textContent = value.toLocaleString();
      }
    };
    update(economyManager.getCoins());
    appBus.on("economy:changed", (payload) => update(payload.coins));
  }

  document.addEventListener("DOMContentLoaded", bindCurrencyDisplay);

  window.AppBus = appBus;
  window.EconomyManager = economyManager;
})();
</file>

<file path="design_rules.md">
Design System Rules (STRICT ENFORCEMENT)

1. Allowed Colors (Use CSS Variables)

Primary Accent: var(--ui-accent) or var(--gold-base)

Backgrounds: var(--ui-bg-base) or var(--material-regular)

Text: var(--ui-text-primary), var(--ui-text-secondary)

2. Components (Copy-Paste These)

Gold Button: <button class="ui-button gold">Play</button>

Glass Button: <button class="ui-button secondary">Cancel</button>

Icon Button: <button class="ui-button mini secondary">âš™ï¸</button>

Card: <div class="glass-panel">...</div>

List: <div class="ui-list"><div class="ui-list-item">...</div></div>

3. Forbidden Actions

âŒ NEVER use style="..." (Inline styles).

âŒ NEVER use Hex codes like #FFFFFF (Use var(--ui-bg-base)).

âŒ NEVER create new CSS classes without asking.
</file>

<file path="effects.js">
class EffectManager {
    constructor(containerSelector) {
        this.container = document.querySelector(containerSelector);
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.particles = [];
        this.resize();

        this.canvas.style.position = 'absolute';
        this.canvas.style.top = '0';
        this.canvas.style.left = '0';
        this.canvas.style.pointerEvents = 'none';
        this.canvas.style.zIndex = '999';
        this.container.appendChild(this.canvas);

        window.addEventListener('resize', () => this.resize());
        this.animate();
    }

    resize() {
        this.canvas.width = this.container.offsetWidth;
        this.canvas.height = this.container.offsetHeight;
    }

    explode(element, value) {
        if (!element) return;
        const rect = element.getBoundingClientRect();
        const containerRect = this.container.getBoundingClientRect();
        const x = rect.left - containerRect.left + rect.width / 2;
        const y = rect.top - containerRect.top + rect.height / 2;

        this.explodeAt(x, y, value);
    }

    explodeAt(x, y, value) {
        this.createParticles(x, y, value);
    }

    rewind() {
        const x = this.canvas.width / 2;
        const y = this.canvas.height / 2;
        const radius = Math.min(this.canvas.width, this.canvas.height) * 0.55;
        const palette = ['#ffffff', '#e0c3fc', '#8ec5fc', '#f6d365', '#fda085'];
        const count = Math.min(200, Math.floor(radius * 0.6));

        this.particles.push(new RewindRing(x, y, radius, '#ffffff'));
        this.particles.push(new RewindRing(x, y, radius * 0.75, '#e0c3fc'));
        this.particles.push(new ClockRing(x, y, radius * 0.9, '#ffffff'));
        this.particles.push(new ClockRing(x, y, radius * 0.65, '#8ec5fc', 36));
        this.particles.push(new ClockHand(x, y, radius * 0.55, 4, '#ffffff', -0.18));
        this.particles.push(new ClockHand(x, y, radius * 0.4, 6, '#f6d365', -0.12));

        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const ringRadius = radius * (0.6 + Math.random() * 0.4);
            const color = palette[i % palette.length];
            this.particles.push(new RewindParticle(x, y, angle, ringRadius, color));
        }
    }

    createParticles(x, y, value) {
        const tier = Math.max(1, Math.log2(value));
        let count = Math.floor(tier * 10); 
        let speedMultiplier = 0.8 + (tier / 8);
        let color = this.getColorForValue(value);
        let sparkleChance = 0;
        
        // Progressive Tiers
        
        // Tier 1 (128+): Single Shockwave
        if (value >= 128) {
             this.particles.push(new Shockwave(x, y, color));
        }

        // Tier 2 (512+): Sparkles introduced, Double Shockwave
        if (value >= 512) {
             count += 20;
             sparkleChance = 0.3; // 30% sparkles
             this.particles.push(new Shockwave(x, y, color, 10)); // 10 frame delay
        }

        // Tier 3 (2048+): Triple Shockwave, Faster, More particles
        if (value >= 2048) {
             count += 40;
             speedMultiplier += 1.0;
             sparkleChance = 0.6; // 60% sparkles
             this.particles.push(new Shockwave(x, y, '#ffffff', 20)); // White shockwave
        }
        
        // Tier 4 (8192+): MAX POWER
        if (value >= 8192) {
            count += 60;
            speedMultiplier += 2.0;
            this.particles.push(new Shockwave(x, y, color, 5));
            this.particles.push(new Shockwave(x, y, color, 15));
            this.particles.push(new Shockwave(x, y, '#ffffff', 30));
        }

        for (let i = 0; i < count; i++) {
            if (Math.random() < sparkleChance) {
                this.particles.push(new Sparkle(x, y, color, speedMultiplier));
            } else {
                this.particles.push(new Particle(x, y, color, speedMultiplier));
            }
        }
    }

    getColorForValue(value) {
        const colors = {
            2: '#eee4da',
            4: '#ede0c8',
            8: '#f2b179',
            16: '#f59563',
            32: '#f67c5f',
            64: '#f65e3b',
            128: '#edcf72',
            256: '#edcc61',
            512: '#edc850',
            1024: '#edc53f',
            2048: '#edc22e',
            4096: '#3e3933',
        };
        return colors[value] || '#ffffff';
    }

    animate() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.globalCompositeOperation = 'lighter';

        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.update();
            p.draw(this.ctx);
            if (p.life <= 0) {
                this.particles.splice(i, 1);
            }
        }
        this.ctx.globalCompositeOperation = 'source-over';

        requestAnimationFrame(() => this.animate());
    }
}

class Particle {
    constructor(x, y, color, speedMultiplier) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const speed = (Math.random() * 3 + 2) * speedMultiplier;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 1.0;
        this.decay = Math.random() * 0.02 + 0.01;
        this.size = Math.random() * 4 + 2;
        this.gravity = 0.1;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += this.gravity;
        this.life -= this.decay;
        this.size *= 0.95; 
    }

    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class Sparkle extends Particle {
    constructor(x, y, color, speedMultiplier) {
        super(x, y, color, speedMultiplier);
        this.decay = Math.random() * 0.01 + 0.005; // Lives longer
    }
    
    draw(ctx) {
        ctx.globalAlpha = this.life * (0.5 + Math.random() * 0.5); // Flicker
        ctx.fillStyle = '#ffffff'; // Sparkles are often white/bright
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 0.8, 0, Math.PI * 2);
        ctx.fill();
        
        // Colored core
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 0.4, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.globalAlpha = 1.0;
    }
}

class Shockwave {
    constructor(x, y, color, delay = 0) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.radius = 1;
        this.maxRadius = 100;
        this.life = 1.0;
        this.decay = 0.02;
        this.delay = delay;
    }

    update() {
        if (this.delay > 0) {
            this.delay--;
            return;
        }
        this.radius += 5;
        this.life -= this.decay;
    }

    draw(ctx) {
        if (this.delay > 0 || this.life <= 0) return;
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.lineWidth = 5;
        ctx.strokeStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    }
}

class RewindParticle {
    constructor(x, y, angle, radius, color) {
        this.x = x + Math.cos(angle) * radius;
        this.y = y + Math.sin(angle) * radius;
        const inward = 2.5 + Math.random() * 2.5;
        const swirl = (Math.random() * 1.2 + 0.4) * (Math.random() < 0.5 ? -1 : 1);
        const dx = Math.cos(angle);
        const dy = Math.sin(angle);
        this.vx = -dx * inward + -dy * swirl;
        this.vy = -dy * inward + dx * swirl;
        this.life = 1.0;
        this.decay = Math.random() * 0.02 + 0.015;
        this.size = Math.random() * 3 + 1;
        this.color = color;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
        this.size *= 0.97;
    }

    draw(ctx) {
        if (this.life <= 0) return;
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.size;
        ctx.shadowBlur = 8;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x - this.vx * 2.5, this.y - this.vy * 2.5);
        ctx.stroke();
        ctx.restore();
    }
}

class RewindRing {
    constructor(x, y, radius, color) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.color = color;
        this.life = 1.0;
        this.decay = 0.04;
    }

    update() {
        this.radius -= 8;
        this.life -= this.decay;
        if (this.radius <= 0) {
            this.life = 0;
        }
    }

    draw(ctx) {
        if (this.life <= 0) return;
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.lineWidth = 6;
        ctx.strokeStyle = this.color;
        ctx.shadowBlur = 12;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    }
}

class ClockRing {
    constructor(x, y, radius, color, tickCount = 60) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.color = color;
        this.tickCount = tickCount;
        this.rotation = Math.random() * Math.PI * 2;
        this.spin = -(Math.random() * 0.08 + 0.06);
        this.life = 1.0;
        this.decay = 0.035;
    }

    update() {
        this.rotation += this.spin;
        this.life -= this.decay;
    }

    draw(ctx) {
        if (this.life <= 0) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.globalAlpha = this.life * 0.9;
        ctx.strokeStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;

        for (let i = 0; i < this.tickCount; i++) {
            const isHour = i % Math.max(1, Math.round(this.tickCount / 12)) === 0;
            const tickLength = isHour ? 14 : 7;
            const tickWidth = isHour ? 3 : 2;
            ctx.lineWidth = tickWidth;
            ctx.beginPath();
            ctx.moveTo(0, -this.radius);
            ctx.lineTo(0, -this.radius + tickLength);
            ctx.stroke();
            ctx.rotate((Math.PI * 2) / this.tickCount);
        }

        ctx.restore();
    }
}

class ClockHand {
    constructor(x, y, length, width, color, speed) {
        this.x = x;
        this.y = y;
        this.length = length;
        this.width = width;
        this.color = color;
        this.rotation = Math.random() * Math.PI * 2;
        this.speed = speed;
        this.life = 1.0;
        this.decay = 0.04;
    }

    update() {
        this.rotation += this.speed;
        this.life -= this.decay;
    }

    draw(ctx) {
        if (this.life <= 0) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.globalAlpha = this.life;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.width;
        ctx.lineCap = 'round';
        ctx.shadowBlur = 12;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, -this.length);
        ctx.stroke();
        ctx.restore();
    }
}
</file>

<file path="GDD.md">
**Project Name:** Arcade City **Genre:** Casual / Simulation / Puzzle **Platform:** Mobile PWA & Web **Monetization:** Free (Soft Currency Only)

**1. Game Concept**
"Build your home, play to earn." A cozy, persistent world where the player's creativity (City & Avatar) is fueled by their skill in classic arcade puzzles.

**2. Core Loops**
**The Gameplay Loop**
1. **Play:** Choose a minigame (2048, Nonogram, Match-3).
2. **Earn:** Completing levels or hitting high scores awards "Coins."
3. **Upgrade:** Use Coins to buy furniture, buildings, or clothes.
4. **Decorate:** Customize the City or Avatar to look cool.

**The Social Loop**
1. **Share:** Send a link to a friend.
2. **Visit:** Friend views your city snapshot.
3. **Interact:** Friend "Likes" your city.
4. **Reward:** You receive a "Social Bonus" of Coins.

**3. The Meta-Game**
**Character Creator**
- **Visuals:** Vector-based Skeletal Animation (e.g., Spine, Rive, or DragonBones).
- **Slots:** Hair, Face, Shirt, Pants, Shoes, Accessories.
- **Progression:** Start with "Basic" set. Unlock "Punk," "Formal," and "Costume" sets via achievements.

**City Builder**
- **View:** Isometric Grid (PixiJS).
- **Mechanics:**
    - Build: Place houses, shops, and roads.
    - Locals: Unlock NPCs (The Baker, The Cop) who wander the roads.
    - Day/Night: Visual tint changes based on the user's real-time clock.

**4. Minigames (Offline Capable)**
**"2048" (The Merger)**
- **Core:** Classic 4x4 grid merging.
- **Twist:** Unlocking visual themes (e.g., City Theme: Bricks -> Windows -> Doors).
- **Reward:** 1 Coin per 10 points.

**"Pixel Logic" (Nonograms)**
- **Core:** Picross logic puzzles (5x5 to 15x15).
- **Controls:** D-Pad overlay for precise cursor movement on mobile.
- **Reward:** Unlocks "Pixel Art" paintings for the player's house.

**"Match-3" (The Crusher)**
- **Core:** Swap tiles to match 3.
- **Tech:** Uses GSAP for precise fluid animations.
- **Modes:** Zen (Endless) and Rush (60s Score Attack).
- **Powerups:** Earned by matching 4 or 5 (Bomb, Line Clear).

**5. Economy**
- **Currency:** Coins (Soft Currency).
- **Sources:** Minigame Gameplay, Daily Login, Visitor Likes.
- **Sinks:** 60% Cosmetics, 30% City Decor, 10% Utilities.

**6. UI/UX**
- **Style:** "Liquid Glass" (Apple HIG). Translucent panels, blur effects, and soft aurora gradients.
- **Navigation (Bottom Bar):**
    - [City] (Home)
    - [Games] (Arcade Menu)
    - [Closet] (Character Editor)
    - [Shop] (Buy Items)
    - [Social] (Leaderboards & Visiting)
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Arcade City</title>
    <link rel="stylesheet" href="ui/theme.css">
    <link rel="stylesheet" href="ui/components.css">
    <link rel="stylesheet" href="style.css?v=10">
    <link rel="stylesheet" href="src/games/2048/style.css?v=10">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#F2F2F7">
    <link rel="icon" href="assets/classic/2048.jpg" sizes="192x192">
    <link rel="apple-touch-icon" href="assets/classic/2048.jpg">
</head>
<body>

    <!-- Leaderboard Modal (Glass Sheet) -->
    <div id="leaderboard" class="overlay hidden">
        <div class="glass-panel overlay-content">
            <div class="overlay-header">
                <h1 id="leaderboard-title" class="ui-title">Leaderboard</h1>
                <button id="close-leaderboard" class="ui-button icon-only secondary" aria-label="Close">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1 1L13 13M1 13L13 1" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
                </button>
            </div>
            <p id="leaderboard-hint" class="ui-caption">Local scores saved on-device. Entries show Score / Turns / Undos.</p>
            
            <div id="leaderboard-entry" class="leaderboard-entry hidden">
                <p class="ui-caption" id="leaderboard-pending">New High Score!</p>
                <div class="leaderboard-form">
                    <input id="player-name" type="text" maxlength="20" autocomplete="name" placeholder="Enter your name">
                    <button id="save-score" class="ui-button small">Save</button>
                </div>
            </div>

            <div id="leaderboard-status" class="leaderboard-status hidden"></div>

            <ul id="high-score-list" class="ui-list">
                <!-- Scores will be injected here -->
            </ul>
            
            <div class="overlay-actions">
                <button id="leaderboard-try-again" class="ui-button small primary hidden">Try Again</button>
                <button id="clear-leaderboard" class="ui-button secondary small">Reset Local</button>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="update-toast" class="glass-pill update-toast hidden" role="status" aria-live="polite">
        <span>Update ready.</span>
        <button id="update-refresh" type="button" class="ui-button small">Refresh</button>
        <button id="update-dismiss" type="button" class="ui-button secondary small">Later</button>
    </div>

    <div class="app-shell">
        <main class="app-main">
            <!-- City View -->
            <section id="view-city" class="view hidden">
                <div class="view-header">
                    <h2>City</h2>
                    <div class="city-tools">
                        <button class="ui-button city-mode active" data-city-mode="place">Place</button>
                        <button class="ui-button secondary city-mode" data-city-mode="erase">Erase</button>
                        <button id="city-clear" class="ui-button secondary">Clear</button>
                        <button id="city-regenerate" class="ui-button secondary">Regen</button>
                    </div>
                </div>
                <div id="city-root" class="city-root" aria-label="City grid"></div>
                <div id="city-palette" class="city-palette"></div>
                <p id="city-hint" class="glass-pill city-hint">Tap map to place.</p>
            </section>

            <!-- Games Menu -->
            <section id="view-games" class="view hidden">
                <div class="view-header">
                    <h2>Arcade</h2>
                    <p class="view-subtitle">Play to earn coins.</p>
                </div>
                <div class="game-list">
                    <div class="game-card">
                        <h3>2048</h3>
                        <p class="ui-caption">Merge photos.</p>
                        <button data-launch="2048" class="ui-button">Play</button>
                    </div>
                    <div class="game-card" data-game="match3">
                        <h3>Match-3</h3>
                        <p class="ui-caption">Coming soon.</p>
                        <button class="ui-button secondary" disabled>Coming Soon</button>
                    </div>
                </div>
            </section>

            <!-- 2048 Game View -->
            <section id="view-2048" class="view">
                <!-- 2048 mounts here -->
            </section>

            <!-- Shop View -->
            <section id="view-shop" class="view hidden">
                <div class="view-header">
                    <h2>Shop</h2>
                    <p class="view-subtitle">Customize your city.</p>
                </div>
                <div id="shop-status" class="shop-status hidden"></div>
                <div id="shop-list" class="shop-list"></div>
            </section>
        </main>

        <!-- Bottom Navigation with SVG Icons -->
        <nav class="bottom-nav hidden" aria-label="Primary">
            <button class="nav-button active" data-view="2048">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M4 4h4v4H4V4zm6 0h4v4h-4V4zm6 0h4v4h-4V4zM4 10h4v4H4v-4zm6 0h4v4h-4v-4zm6 0h4v4h-4v-4zM4 16h4v4H4v-4zm6 0h4v4h-4v-4zm6 0h4v4h-4v-4z"/></svg>
                <span>2048</span>
            </button>
            <button class="nav-button" data-view="city">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
                <span>City</span>
            </button>
            <button class="nav-button" data-view="games">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M21 6H3c-1.1 0-2 .9-2 2v8c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-10 7H8v3H6v-3H3v-2h3V8h2v3h3v2zm4.5 2c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm4-3c-.83 0-1.5-.67-1.5-1.5S18.67 9 19.5 9s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></svg>
                <span>Arcade</span>
            </button>
            <button class="nav-button" data-view="shop">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 6h-2c0-2.76-2.24-5-5-5S7 3.24 7 6H5c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-7-3c1.66 0 3 1.34 3 3H9c0-1.66 1.34-3 3-3zm0 10c-1.1 0-2-.9-2-2h-2c0 2.21 1.79 4 4 4s4-1.79 4-4h-2c0 1.1-.9 2-2 2z"/></svg>
                <span>Shop</span>
            </button>
        </nav>
    </div>

    <!-- Settings Overlay -->
    <div id="settings-overlay" class="overlay hidden">
        <div class="glass-panel overlay-content settings-panel">
            <div class="overlay-header">
                <h1 class="ui-title">Settings</h1>
                <button id="close-settings" class="ui-button icon-only secondary" aria-label="Close">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1 1L13 13M1 13L13 1" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
                </button>
            </div>
            <div class="settings-row">
                <span class="ui-title" style="font-size:16px;">Theme</span>
                <label class="ui-toggle">
                    <input type="checkbox" id="theme-toggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="settings-row">
                <div style="display:flex; flex-direction:column; gap:4px;">
                    <span class="ui-title" style="font-size:16px;">PWA Update</span>
                    <span class="ui-caption">Force reload to pick up latest cached assets.</span>
                </div>
                <button id="pwa-refresh" class="ui-button secondary small">Refresh</button>
            </div>
            <div class="settings-row" style="flex-direction:column; align-items:flex-start; gap:10px;">
                <span class="ui-title" style="font-size:16px;">Dev Tools</span>
                <div style="display:flex; gap:8px; flex-wrap:wrap;">
                    <button id="dev-game-over" class="ui-button secondary small">Force Game Over</button>
                    <button id="dev-add-2048" class="ui-button secondary small">Add 2048 Tile</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Core Dependencies -->
    <script src="core.js"></script>
    <script src="effects.js"></script>
    
    <!-- Game Architecture -->
    <script type="module" src="src/core/GameInterface.js"></script>
    <script type="module" src="src/core/ThemeManager.js"></script>
    <script type="module" src="src/core/FirebaseManager.js"></script>

    <!-- Legacy City Modules -->
    <script>
      // Firebase config injected before app.js so FirebaseManager can auto-init
      window.firebaseConfig = {
        apiKey: "AIzaSyAn2ZDH7D7R9yArS2QfO7tvdsJDccZrzcU",
        authDomain: "our-city-4d536.firebaseapp.com",
        projectId: "our-city-4d536",
        storageBucket: "our-city-4d536.firebasestorage.app",
        messagingSenderId: "99991718389",
        appId: "1:99991718389:web:da368f4d8d48cdee64b8bc",
        measurementId: "G-XDTXTBKD6D"
      };
    </script>

    <!-- App Entry Point -->
    <script type="module" src="app.js"></script>
</body>
</html>
</file>

<file path="jules/.gitignore">
node_modules/
dist/
.DS_Store
</file>

<file path="jules/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixi Game Center</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <!-- Play Overlay -->
    <div id="play-overlay" class="overlay hidden">
        <div class="modal">
            <h2>Start 2048</h2>
            <p>Ready to play?</p>
            <button id="play-btn">Play 2048</button>
            <button onclick="document.getElementById('play-overlay').classList.add('hidden')">Cancel</button>
        </div>
    </div>
    
    <script type="module" src="/src/main.js"></script>
</body>
</html>
</file>

<file path="jules/package.json">
{
  "name": "pixi-game-center",
  "version": "1.0.0",
  "description": "A PWA Game Center with Pixi.js",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "gsap": "^3.14.2",
    "pixi.js": "^8.15.0"
  },
  "devDependencies": {
    "vite": "^7.3.1"
  }
}
</file>

<file path="jules/src/AssetLoader.js">
import { Assets } from 'pixi.js';

export class AssetLoader {
    constructor() {
        this.manifest = {
            bundles: [
                {
                    name: '2048-classic',
                    assets: [
                        { alias: '2', src: '/assets/2048/2.jpg' },
                        { alias: '4', src: '/assets/2048/4.jpg' },
                        { alias: '8', src: '/assets/2048/8.jpg' },
                        { alias: '16', src: '/assets/2048/16.jpg' },
                        { alias: '32', src: '/assets/2048/32.jpg' },
                        { alias: '64', src: '/assets/2048/64.jpg' },
                        { alias: '128', src: '/assets/2048/128.jpg' },
                        { alias: '256', src: '/assets/2048/256.jpg' },
                        { alias: '512', src: '/assets/2048/512.jpg' },
                        { alias: '1024', src: '/assets/2048/1024.jpg' },
                        { alias: '2048', src: '/assets/2048/2048.jpg' },
                        { alias: '4096', src: '/assets/2048/4096.jpg' },
                        { alias: '8192', src: '/assets/2048/8192.jpg' },
                        { alias: '16384', src: '/assets/2048/16384.jpg' },
                        { alias: '32768', src: '/assets/2048/32768.jpg' }
                    ]
                }
            ]
        };
    }

    async init() {
        await Assets.init({ manifest: this.manifest });
    }

    async loadBundle(bundleName) {
        return await Assets.loadBundle(bundleName);
    }
}
</file>

<file path="jules/src/CityScene.js">
import { Container, Graphics, Text } from 'pixi.js';
import { Viewport } from './Viewport.js';

export class CityScene {
    constructor(app, gameManager) {
        this.app = app;
        this.gameManager = gameManager;
        
        // Create viewport
        this.viewport = new Viewport(app);
        this.app.stage.addChild(this.viewport);
        
        // Add background
        const bg = new Graphics();
        bg.rect(-2000, -2000, 4000, 4000);
        bg.fill(0x333333); // Dark grey ground
        
        // Grid lines
        // Graphics API v8
        for (let x = -2000; x <= 2000; x += 100) {
            bg.moveTo(x, -2000).lineTo(x, 2000).stroke({ width: 2, color: 0x444444 });
        }
        for (let y = -2000; y <= 2000; y += 100) {
            bg.moveTo(-2000, y).lineTo(2000, y).stroke({ width: 2, color: 0x444444 });
        }
        
        this.viewport.addChild(bg);

        // Add dummy buildings
        this.addBuilding(0, 0, '2048 Center', 0x00AAFF);
        this.addBuilding(300, 100, 'Residential', 0x00FFAA);
        this.addBuilding(-200, -300, 'Factory', 0xFF00AA);
    }

    addBuilding(x, y, name, color) {
        // Create a simple building sprite/graphic
        const building = new Container();
        building.position.set(x, y);
        building.eventMode = 'static';
        building.cursor = 'pointer';

        const graphics = new Graphics();
        graphics.rect(-50, -50, 100, 100);
        graphics.fill(color);
        graphics.stroke({ width: 2, color: 0xFFFFFF });
        
        const label = new Text({ text: name, style: { fontSize: 16, fill: 0xFFFFFF, align: 'center' } });
        label.anchor.set(0.5);
        label.position.set(0, 60);

        building.addChild(graphics, label);
        
        building.on('pointertap', (e) => {
            // Check if we were dragging the viewport. If so, don't trigger click.
            // But pointertap is usually smart enough.
            // However, our viewport dragging logic might interfere.
            // Viewport uses pointermove.
            // Let's rely on pointertap.
            this.onBuildingClick(name);
        });

        this.viewport.addChild(building);
    }

    onBuildingClick(name) {
        console.log(`Clicked building: ${name}`);
        // Trigger event or callback
        if (name === '2048 Center') {
            this.gameManager.showPlayOverlay();
        }
    }

    pause() {
        this.viewport.visible = false;
        this.viewport.eventMode = 'none';
    }

    resume() {
        this.viewport.visible = true;
        this.viewport.eventMode = 'static';
    }
}
</file>

<file path="jules/src/GameManager.js">
import { Application } from 'pixi.js';
import { AssetLoader } from './AssetLoader.js';
import { CityScene } from './CityScene.js';
import { Game2048 } from './games/2048/Game2048.js';

export class GameManager {
    constructor() {
        this.app = new Application();
        this.assetLoader = new AssetLoader();
        this.currentMinigame = null;
    }

    async init() {
        await this.app.init({ background: '#1099bb', resizeTo: window });
        document.body.appendChild(this.app.canvas);
        
        await this.assetLoader.init();
        await this.assetLoader.loadBundle('2048-classic');
        
        this.cityScene = new CityScene(this.app, this);
        
        // Setup Minigames
        this.minigames = {
            '2048': new Game2048(this.app, this)
        };
        
        // Start in City
        this.cityScene.resume();
    }
    
    // Called by CityScene or UI
    showPlayOverlay() {
        const overlay = document.getElementById('play-overlay');
        if (overlay) overlay.classList.remove('hidden');
    }
    
    startGame() {
        const overlay = document.getElementById('play-overlay');
        if (overlay) overlay.classList.add('hidden');
        
        this.cityScene.pause();
        this.currentMinigame = this.minigames['2048'];
        this.currentMinigame.start();
    }
    
    onMinigameEnd(score) {
        console.log(`Minigame ended with score: ${score}`);
        this.currentMinigame = null;
        this.cityScene.resume();
    }
}
</file>

<file path="jules/src/games/2048/Game2048.js">
import { MinigameBase } from '../../MinigameBase.js';
import { Game2048Logic } from './Logic.js';
import { PixiRenderer } from './PixiRenderer.js';
import { Text, Graphics } from 'pixi.js';

export class Game2048 extends MinigameBase {
    constructor(app, gameManager) {
        super(app, gameManager);
        this.logic = new Game2048Logic();
        this.renderer = new PixiRenderer(this.container, this.logic);
        
        // Add back button
        this.createUI();
    }
    
    createUI() {
        const backBtn = new Graphics();
        backBtn.roundRect(0, 0, 100, 40, 5);
        backBtn.fill(0x8f7a66);
        backBtn.position.set(20, 20);
        backBtn.eventMode = 'static';
        backBtn.cursor = 'pointer';
        
        const label = new Text({ text: "Back", style: { fontSize: 20, fill: 0xFFFFFF } });
        label.anchor.set(0.5);
        label.position.set(50, 20);
        backBtn.addChild(label);
        
        backBtn.on('pointertap', () => {
             this.end(this.logic.score);
        });
        
        this.container.addChild(backBtn);
        
        this.scoreText = new Text({ text: "Score: 0", style: { fontSize: 24, fill: 0x776e65 } });
        this.scoreText.position.set(window.innerWidth / 2, 50);
        this.scoreText.anchor.set(0.5, 0);
        this.container.addChild(this.scoreText);
    }

    async start() {
        await super.start();
        this.logic.setup();
        this.renderer.drawBackground();
        this.renderer.update(this.logic.grid);
        this.updateScore();
        
        this.bindInput();
        
        // Resize listener
        window.addEventListener('resize', this.onResize.bind(this));
    }
    
    onResize() {
        this.renderer.resize();
        if (this.scoreText) {
             this.scoreText.position.set(window.innerWidth / 2, 50);
        }
    }
    
    bindInput() {
        this._keyDownHandler = this.onKeyDown.bind(this);
        window.addEventListener('keydown', this._keyDownHandler);
    }
    
    unbindInput() {
        window.removeEventListener('keydown', this._keyDownHandler);
        window.removeEventListener('resize', this.onResize.bind(this));
    }

    onKeyDown(event) {
        const map = {
            38: 0, // Up
            39: 1, // Right
            40: 2, // Down
            37: 3, // Left
            87: 0, // W
            68: 1, // D
            83: 2, // S
            65: 3  // A
        };
        const modifiers = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;
        const mapped = map[event.which];

        if (!modifiers && mapped !== undefined) {
            event.preventDefault();
            const moved = this.logic.move(mapped);
            if (moved) {
                this.renderer.update(this.logic.grid);
                this.updateScore();
                
                if (this.logic.isGameTerminated()) {
                    setTimeout(() => {
                        alert(this.logic.won ? "You Won!" : "Game Over! Score: " + this.logic.score);
                        this.end(this.logic.score);
                    }, 500);
                }
            }
        }
    }
    
    updateScore() {
        if (this.scoreText) {
            this.scoreText.text = `Score: ${this.logic.score}`;
        }
    }
    
    end(score) {
        this.unbindInput();
        super.end(score);
    }
}
</file>

<file path="jules/src/games/2048/Logic.js">
// src/games/2048/Logic.js

export class Tile {
  constructor(position, value) {
    this.x = position.x;
    this.y = position.y;
    this.value = value || 2;
    this.previousPosition = null;
    this.mergedFrom = null; 
    this._id = Math.random().toString(36).substr(2, 9);
  }

  savePosition() {
    this.previousPosition = { x: this.x, y: this.y };
  }

  updatePosition(position) {
    this.x = position.x;
    this.y = position.y;
  }
  
  serialize() {
    return {
      position: { x: this.x, y: this.y },
      value: this.value
    };
  }
}

export class Grid {
  constructor(size, previousState) {
    this.size = size;
    this.cells = previousState ? this.fromState(previousState) : this.empty();
  }

  empty() {
    const cells = [];
    for (let x = 0; x < this.size; x++) {
      const row = (cells[x] = []);
      for (let y = 0; y < this.size; y++) {
        row.push(null);
      }
    }
    return cells;
  }

  fromState(state) {
    const cells = [];
    for (let x = 0; x < this.size; x++) {
      const row = (cells[x] = []);
      for (let y = 0; y < this.size; y++) {
        const tile = state[x][y];
        row.push(tile ? new Tile(tile.position, tile.value) : null);
      }
    }
    return cells;
  }

  randomAvailableCell() {
    const cells = this.availableCells();
    if (cells.length) {
      return cells[Math.floor(Math.random() * cells.length)];
    }
  }

  availableCells() {
    const cells = [];
    this.eachCell((x, y, tile) => {
      if (!tile) {
        cells.push({ x: x, y: y });
      }
    });
    return cells;
  }

  eachCell(callback) {
    for (let x = 0; x < this.size; x++) {
      for (let y = 0; y < this.size; y++) {
        callback(x, y, this.cells[x][y]);
      }
    }
  }

  cellsAvailable() {
    return !!this.availableCells().length;
  }

  cellAvailable(cell) {
    return !this.cellContent(cell);
  }

  cellContent(cell) {
    if (this.withinBounds(cell)) {
      return this.cells[cell.x][cell.y];
    } else {
      return null;
    }
  }

  insertTile(tile) {
    this.cells[tile.x][tile.y] = tile;
  }

  removeTile(tile) {
    this.cells[tile.x][tile.y] = null;
  }

  withinBounds(position) {
    return (
      position.x >= 0 &&
      position.x < this.size &&
      position.y >= 0 &&
      position.y < this.size
    );
  }
}

export class Game2048Logic {
    constructor(size = 4) {
        this.size = size;
        this.startTiles = 2;
        this.grid = new Grid(this.size);
        this.score = 0;
        this.over = false;
        this.won = false;
        this.keepPlaying = false;
    }

    setup() {
        this.grid = new Grid(this.size);
        this.score = 0;
        this.over = false;
        this.won = false;
        this.keepPlaying = false;
        this.addStartTiles();
    }

    addStartTiles() {
        for (let i = 0; i < this.startTiles; i++) {
            this.addRandomTile();
        }
    }

    addRandomTile() {
        if (this.grid.cellsAvailable()) {
            const value = Math.random() < 0.9 ? 2 : 4;
            const tile = new Tile(this.grid.randomAvailableCell(), value);
            this.grid.insertTile(tile);
        }
    }

    prepareTiles() {
        this.grid.eachCell((x, y, tile) => {
            if (tile) {
                tile.mergedFrom = null;
                tile.savePosition();
            }
        });
    }

    moveTile(tile, cell) {
        this.grid.cells[tile.x][tile.y] = null;
        this.grid.cells[cell.x][cell.y] = tile;
        tile.updatePosition(cell);
    }

    move(direction) {
        // 0: up, 1: right, 2: down, 3: left
        if (this.isGameTerminated()) return false;

        const vector = this.getVector(direction);
        const traversals = this.buildTraversals(vector);
        let moved = false;

        this.prepareTiles();

        traversals.x.forEach((x) => {
            traversals.y.forEach((y) => {
                const cell = { x: x, y: y };
                const tile = this.grid.cellContent(cell);

                if (tile) {
                    const positions = this.findFarthestPosition(cell, vector);
                    const next = this.grid.cellContent(positions.next);

                    if (next && next.value === tile.value && !next.mergedFrom) {
                        const merged = new Tile(positions.next, tile.value * 2);
                        merged.mergedFrom = [tile, next];

                        this.grid.insertTile(merged);
                        this.grid.removeTile(tile);

                        tile.updatePosition(positions.next);

                        this.score += merged.value;

                        if (merged.value === 2048) {
                            this.won = true;
                        }
                    } else {
                        this.moveTile(tile, positions.farthest);
                    }

                    if (!this.positionsEqual(cell, tile)) {
                        moved = true;
                    }
                }
            });
        });

        if (moved) {
            this.addRandomTile();
            if (!this.movesAvailable()) {
                this.over = true;
            }
            return true;
        }
        return false;
    }

    getVector(direction) {
        const map = {
            0: { x: 0, y: -1 }, // Up
            1: { x: 1, y: 0 }, // Right
            2: { x: 0, y: 1 }, // Down
            3: { x: -1, y: 0 }, // Left
        };
        return map[direction];
    }

    buildTraversals(vector) {
        const traversals = { x: [], y: [] };

        for (let pos = 0; pos < this.size; pos++) {
            traversals.x.push(pos);
            traversals.y.push(pos);
        }

        if (vector.x === 1) traversals.x = traversals.x.reverse();
        if (vector.y === 1) traversals.y = traversals.y.reverse();

        return traversals;
    }

    findFarthestPosition(cell, vector) {
        let previous;
        do {
            previous = cell;
            cell = { x: previous.x + vector.x, y: previous.y + vector.y };
        } while (this.grid.withinBounds(cell) && this.grid.cellAvailable(cell));

        return {
            farthest: previous,
            next: cell,
        };
    }

    movesAvailable() {
        return this.grid.cellsAvailable() || this.tileMatchesAvailable();
    }

    tileMatchesAvailable() {
        let tile;
        for (let x = 0; x < this.size; x++) {
            for (let y = 0; y < this.size; y++) {
                tile = this.grid.cellContent({ x: x, y: y });
                if (tile) {
                    for (let direction = 0; direction < 4; direction++) {
                        const vector = this.getVector(direction);
                        const cell = { x: x + vector.x, y: y + vector.y };
                        const other = this.grid.cellContent(cell);
                        if (other && other.value === tile.value) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    positionsEqual(first, second) {
        return first.x === second.x && first.y === second.y;
    }

    isGameTerminated() {
        return this.over || (this.won && !this.keepPlaying);
    }
}
</file>

<file path="jules/src/games/2048/PixiRenderer.js">
import { Container, Graphics, Sprite, Text, Assets } from 'pixi.js';
import gsap from 'gsap';

export class PixiRenderer {
    constructor(container, logic) {
        this.container = container;
        this.logic = logic;
        
        this.tileSize = 100;
        this.padding = 10;
        
        this.gridContainer = new Container();
        this.container.addChild(this.gridContainer);
        
        this.centerGrid();

        this.sprites = {}; // Map of tile ID to Sprite/Container
        this.tileLayer = new Container();
    }
    
    centerGrid() {
         const gridWidth = (this.tileSize + this.padding) * 4 + this.padding;
         this.gridContainer.position.set(
            (window.innerWidth - gridWidth) / 2,
            (window.innerHeight - gridWidth) / 2
        );
    }
    
    resize() {
        this.centerGrid();
    }

    drawBackground() {
        this.gridContainer.removeChildren();
        
        const bg = new Graphics();
        const fullSize = (this.tileSize + this.padding) * 4 + this.padding;
        bg.roundRect(0, 0, fullSize, fullSize, 10);
        bg.fill(0xbbada0);
        
        this.gridContainer.addChild(bg);
        
        for(let x=0; x<4; x++) {
            for(let y=0; y<4; y++) {
                const cell = new Graphics();
                const pos = this.getPosition(x, y);
                cell.roundRect(pos.x, pos.y, this.tileSize, this.tileSize, 5);
                cell.fill(0xcdc1b4);
                this.gridContainer.addChild(cell);
            }
        }
        
        this.tileLayer = new Container();
        this.gridContainer.addChild(this.tileLayer);
        this.sprites = {};
    }

    getPosition(x, y) {
        return {
            x: this.padding + x * (this.tileSize + this.padding),
            y: this.padding + y * (this.tileSize + this.padding)
        };
    }
    
    update(grid) {
        const toRemove = new Set(Object.keys(this.sprites));
        
        grid.eachCell((x, y, tile) => {
            if (tile) {
                if (this.sprites[tile._id]) {
                    toRemove.delete(tile._id);
                    this.updateTile(tile);
                } else {
                    this.addTile(tile, toRemove);
                }
            }
        });
        
        toRemove.forEach(id => {
            const sprite = this.sprites[id];
            sprite.destroy();
            delete this.sprites[id];
        });
    }

    addTile(tile, toRemove) {
        const container = new Container();
        
        // Background/Image
        let bg;
        // Check if asset is loaded
        const texture = Assets.get(String(tile.value));
        if (texture) {
             bg = new Sprite(texture);
             bg.width = this.tileSize;
             bg.height = this.tileSize;
        } else {
             bg = new Graphics();
             bg.roundRect(0,0,this.tileSize, this.tileSize, 5);
             bg.fill(0xeee4da);
             
             const text = new Text({ text: String(tile.value), style: { fontSize: 40, fill: 0x776e65 } });
             text.anchor.set(0.5);
             text.position.set(this.tileSize/2, this.tileSize/2);
             bg.addChild(text);
        }
        
        container.addChild(bg);
        
        this.tileLayer.addChild(container);
        this.sprites[tile._id] = container;
        
        const dest = this.getPosition(tile.x, tile.y);
        
        if (tile.previousPosition) {
            const src = this.getPosition(tile.previousPosition.x, tile.previousPosition.y);
            container.position.set(src.x, src.y);
            gsap.to(container.position, { x: dest.x, y: dest.y, duration: 0.1 });
        } else if (tile.mergedFrom) {
             container.position.set(dest.x, dest.y);
             container.scale.set(0);
             gsap.to(container.scale, { x: 1, y: 1, duration: 0.2, ease: "back.out(1.7)" });
             
             if (toRemove) {
                 tile.mergedFrom.forEach(merged => {
                     const sprite = this.sprites[merged._id];
                     if (sprite) {
                         toRemove.delete(merged._id);
                         delete this.sprites[merged._id]; 
                         
                         // Keep it in layer but behind new tile
                         this.tileLayer.setChildIndex(sprite, 0);

                         gsap.to(sprite.position, { x: dest.x, y: dest.y, duration: 0.1, onComplete: () => {
                             sprite.destroy();
                         }});
                     }
                 });
             }
        } else {
             // New tile appear
             container.position.set(dest.x, dest.y);
             container.scale.set(0);
             gsap.to(container.scale, { x: 1, y: 1, duration: 0.2 });
        }
    }

    updateTile(tile) {
        const sprite = this.sprites[tile._id];
        const dest = this.getPosition(tile.x, tile.y);
        gsap.to(sprite.position, { x: dest.x, y: dest.y, duration: 0.1 });
    }
}
</file>

<file path="jules/src/main.js">
import { GameManager } from './GameManager.js';

const game = new GameManager();
game.init();

// Expose game for UI interaction
window.game = game;

// Bind Play Button
const playBtn = document.getElementById('play-btn');
if (playBtn) {
    playBtn.addEventListener('click', () => {
        game.startGame();
    });
}
</file>

<file path="jules/src/MinigameBase.js">
import { Container } from 'pixi.js';

export class MinigameBase {
    constructor(app, gameManager) {
        this.app = app;
        this.gameManager = gameManager;
        this.container = new Container();
        this.container.visible = false;
        this.app.stage.addChild(this.container);
    }

    // Called when the game starts
    async start() {
        this.container.visible = true;
        // To be implemented by subclasses
    }

    // Called when the game ends
    end(score) {
        this.container.visible = false;
        this.gameManager.onMinigameEnd(score);
    }

    destroy() {
        if (this.container.parent) {
            this.container.parent.removeChild(this.container);
        }
        this.container.destroy({ children: true });
    }
}
</file>

<file path="jules/src/Viewport.js">
import { Container, Rectangle } from 'pixi.js';

export class Viewport extends Container {
    constructor(app) {
        super();
        this.app = app;
        
        this.eventMode = 'static';
        // Use a very large hit area so we can drag empty space
        this.hitArea = new Rectangle(-50000, -50000, 100000, 100000);

        this.dragging = false;
        this.lastPosition = null;
        
        // Multitouch
        this.pointers = new Map();
        this.initialPinchDist = null;
        this.initialScale = 1;

        this.on('pointerdown', this.onPointerDown, this);
        this.on('pointerup', this.onPointerUp, this);
        this.on('pointerupoutside', this.onPointerUp, this);
        this.on('pointermove', this.onPointerMove, this);
        // this.app.view.addEventListener('wheel', this.onWheel.bind(this), { passive: false });
        // In Pixi v8 we can listen to wheel on container if eventMode is static
        this.on('wheel', this.onWheel, this);
    }

    onPointerDown(event) {
        this.pointers.set(event.pointerId, event.global.clone());
        if (this.pointers.size === 1) {
             this.dragging = true;
             this.lastPosition = event.global.clone();
        } else if (this.pointers.size === 2) {
             this.dragging = false; // Switch to zoom
             this.initialPinchDist = this.getPinchDist();
             this.initialScale = this.scale.x;
        }
    }

    onPointerUp(event) {
        this.pointers.delete(event.pointerId);
        if (this.pointers.size < 2) {
            this.initialPinchDist = null;
        }
        if (this.pointers.size === 1) {
            this.dragging = true;
            // Update lastPosition to the remaining pointer
            const p = this.pointers.values().next().value;
            this.lastPosition = p.clone();
        } else if (this.pointers.size === 0) {
            this.dragging = false;
        }
    }

    onPointerMove(event) {
        if (!this.pointers.has(event.pointerId)) return;
        this.pointers.set(event.pointerId, event.global.clone());

        if (this.pointers.size === 2) {
            // Pinch
            const currentDist = this.getPinchDist();
            if (this.initialPinchDist) {
                const scale = (currentDist / this.initialPinchDist) * this.initialScale;
                // Clamp scale
                const newScale = Math.max(0.1, Math.min(scale, 5));
                this.scale.set(newScale);
            }
        } else if (this.dragging && this.pointers.size === 1) {
            const newPosition = this.pointers.get(event.pointerId);
            const dx = newPosition.x - this.lastPosition.x;
            const dy = newPosition.y - this.lastPosition.y;
            
            this.position.x += dx;
            this.position.y += dy;
            
            this.lastPosition = newPosition.clone();
        }
    }

    getPinchDist() {
        const points = Array.from(this.pointers.values());
        const p1 = points[0];
        const p2 = points[1];
        return Math.hypot(p2.x - p1.x, p2.y - p1.y);
    }

    onWheel(event) {
        event.preventDefault();
        const zoomFactor = 0.999; // Smooth zoom
        // event.deltaY is usually around 100 or -100
        const scaleChange = Math.pow(zoomFactor, event.deltaY);
        
        const worldPos = this.toLocal(event.global);
        
        let newScale = this.scale.x * scaleChange;
        newScale = Math.max(0.1, Math.min(newScale, 5));
        
        this.scale.set(newScale);
        
        const newWorldPos = this.toGlobal(worldPos);
        this.position.x += event.global.x - newWorldPos.x;
        this.position.y += event.global.y - newWorldPos.y;
    }
}
</file>

<file path="jules/style.css">
body {
    margin: 0;
    overflow: hidden;
    background: #000;
    touch-action: none; /* Prevent browser zooming/scrolling */
    font-family: sans-serif;
}

.overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 100;
}

.hidden {
    display: none !important;
}

.modal {
    background: white;
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

button {
    padding: 10px 20px;
    margin: 5px;
    font-size: 16px;
    cursor: pointer;
    background: #00AAFF;
    color: white;
    border: none;
    border-radius: 5px;
}

button:hover {
    background: #0088CC;
}
</file>

<file path="jules/test/test_2048_logic.js">
import { Game2048Logic, Grid, Tile } from '../src/games/2048/Logic.js';
import assert from 'assert';

const game = new Game2048Logic(4);
game.setup();

console.log('Testing 2048 Logic...');

// Test 1: Initial state
assert.equal(game.grid.availableCells().length, 14, 'Should have 14 available cells (2 started)');
console.log('Initial state passed');

// Test 2: Moving
// Setup a specific grid
// [2, 0, 0, 0]
// [0, 0, 0, 0]
// [0, 0, 0, 0]
// [0, 0, 0, 0]
game.grid = new Grid(4);
game.grid.insertTile(new Tile({x: 0, y: 0}, 2));
game.score = 0;

// Move Right (direction 1)
// Should be [0, 0, 0, 2]
// Note: move() also adds a random tile if moved.
const moved = game.move(1);
assert.ok(moved, 'Should have moved');

const tile = game.grid.cellContent({x: 3, y: 0});
assert.ok(tile, 'Tile should be at (3,0)');
assert.equal(tile.value, 2, 'Tile value should be 2');
assert.equal(game.grid.cellContent({x: 0, y: 0}), null, 'Original cell should be empty');
console.log('Move Right passed');

// Test 3: Merging
// [2, 2, 0, 0] -> Move Right -> [0, 0, 0, 4]
game.grid = new Grid(4);
game.grid.insertTile(new Tile({x: 0, y: 0}, 2));
game.grid.insertTile(new Tile({x: 1, y: 0}, 2));
game.score = 0;

game.move(1);

const merged = game.grid.cellContent({x: 3, y: 0});
assert.ok(merged, 'Merged tile should be at (3,0)');
assert.equal(merged.value, 4, 'Merged value should be 4');
assert.equal(game.score, 4, 'Score should be 4');
console.log('Merge Right passed');

console.log('All tests passed!');
</file>

<file path="manifest.json">
{
  "name": "Photo 2048",
  "short_name": "Photo2048",
  "start_url": "./index.html",
  "display": "standalone",
  "background_color": "#faf8ef",
  "theme_color": "#8f7a66",
  "orientation": "portrait",
  "icons": [
    {
      "src": "assets/classic/2048.jpg",
      "sizes": "192x192",
      "type": "image/jpeg"
    },
    {
      "src": "assets/classic/2048.jpg",
      "sizes": "512x512",
      "type": "image/jpeg"
    }
  ]
}
</file>

<file path="notes/progress_2026-01-18.md">
# Progress â€“ 2026-01-18

## What changed
- Polished 2048 header: mini glass buttons for Scores/Settings, gold primary CTA, and full-height Undo for consistent sizing.
- Tightened score/best chips with centered text and theme-aware colors for both light and dark modes.
- Leaderboard rebuilt into glassy cards with clear names, medal ranks, stacked undo/turn stats, and a transparent sheet that lets the popup background show through.
- Button styling unified via `ui-button` variants (primary/secondary/gold/mini) instead of per-screen overrides.
- Documentation refreshed to capture the design component usage so future UI fixes reuse the shared library.

## Notes / next steps
- Keep using the shared button variants and leaderboard card structure for any new overlays to avoid ad-hoc styling.
- If adding new stats to leaderboards, extend the existing `.lb-stat-stack` rather than changing the row layout.
</file>

<file path="notes/progress_2026-01-19.md">
# Progress - 2026-01-19

## What changed
- Expanded the 2048 touch target: introduced a `.game-stage` wrapper sized to the full play area with safe-area padding and `touch-action: none`, so swipes register even in the empty space beneath the board.
- Pointed the pointer-based `KeyboardInputManager` at `.game-stage` first (falling back to `.game-container`) to unify swipe handling across the larger hitbox without blocking header buttons.
- Documented the new input behavior in README, TDD, and roadmap for future UI work.

## Notes / next steps
- If any overlay (e.g., effect canvas) steals touches, set `pointer-events: none` on that layer to keep swipes responsive.
- After deployment, ask PWA users to reload/clear cached data so the new bundle and styles take effect.
</file>

<file path="notes/progress_20260118.md">
# Progress 20260118

## Findings (code review)
- Firebase leaderboards still need the composite index (gameId asc + score desc) to avoid â€œrequires an indexâ€ errors; indexRequired flag is set but wonâ€™t resolve without creating the index. (src/core/FirebaseManager.js)
- Economy/coins UI is now hidden, but EconomyManager still emits updates; if you re-enable coins, ensure a visible element with .score-value exists or guard the updater further. (core.js)
- Bottom nav is completely hidden; only 2048 is reachable. This matches â€œ2048 onlyâ€ but blocks city/shop testing without CSS changes. (style.css)

## Changes made now
- Hid coins chip in the 2048 header (.currency-container { display:none; }).
- Hid the bottom nav to gate unfinished features; 2048 remains accessible via the header.
- Settings cog lives in the header group; click delegates to the settings overlay even when injected.
- Increased contrast on stat labels (Score/Best/Coins label styling adjusted).
- Centered CTA text on the game-over button via flex centering and line-height.

## Docs updated
- README.md: noted current scope (only 2048 exposed; nav hidden; coins UI suppressed).
- TDD.md: added current UI state (2048-only surface, hidden nav/coins, settings via header cog).
- roadmap.md: added navigation gating item.

## Notes on â€œcoins labelâ€
- The label is still in the DOM but hidden via CSS per request. If you want to debug visibility instead, remove the display:none on .currency-container in src/games/2048/style.css.

## Files touched
- src/games/2048/style.css (hide coins, stat label contrast, CTA text centering)
- style.css (hide bottom nav)
- app.js (settings overlay delegation)
- README.md, TDD.md, roadmap.md (current progress/scope)

## Next steps (optional)
1) If you want the Coins label visible again, remove the display:none on .currency-container; I can also harden the updater to no-op when hidden.
2) If you need nav back for testing city/shop, I can re-show it but keep disabled states.
</file>

<file path="package.json">
{
  "name": "bobstan2048",
  "version": "1.0.0",
  "description": "A modern, \"Apple-style\" redesign of the classic 2048 game, featuring liquid glass aesthetics and custom photo tiles.",
  "main": "effects.js",
  "scripts": {
    "dev": "vite",
    "build": "vite build"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/bostannnn/bostan2048.git"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "module",
  "bugs": {
    "url": "https://github.com/bostannnn/bostan2048/issues"
  },
  "homepage": "https://github.com/bostannnn/bostan2048#readme",
  "devDependencies": {
    "vite": "^7.3.1"
  },
  "dependencies": {
    "pixi.js": "^8.15.0"
  }
}
</file>

<file path="README.md">
# Arcade City (ESM Version)

## ðŸ¤– Agent Protocol (MANDATORY)
**For all AI Agents and Developers:**
1.  **Documentation First:** If you modify functionality, architecture, or features, you **MUST** update `README.md` (this file), `TDD.md`, and `roadmap.md` in the same session.
2.  **No Stale Docs:** Ensure the documentation accurately reflects the code state at the end of your turn.
3.  **Modular Strictness:** Maintain the ES Module architecture. Do not introduce global scripts unless absolutely necessary for legacy compatibility.

---

A modern, modular Progressive Web App (PWA) combining a City Builder meta-game with classic arcade puzzles.

## ðŸš€ Development

This project uses **ES Modules**, which requires a local web server to run.

1.  **Install dependencies:**
    ```bash
    npm install
    ```

2.  **Start the dev server:**
    ```bash
    npm run dev -- --host
    ```

3.  **Open in Browser:**
    Open the URL shown in your terminal (e.g., `http://localhost:5173` or the Network IP).

## ðŸŽ¨ Design System (Apple HIG)

The UI uses a **Liquid Glass** aesthetic inspired by iOS with soft aurora backdrops.
*   **Tokens:** Defined in `ui/theme.css` (system colors, aurora gradients, motion durations).
*   **Components:** `ui/components.css` contains `glass-panel`, `glass-pill`, `ui-button`, focus-visible states.
*   **Motion:** `--motion-*` tokens drive subtle float/drift animations; respects `prefers-reduced-motion`.
*   **Dark Mode:** Supported via automatic system preference and a manual toggle (top-left).

## ðŸ— Modular Architecture

The project follows a **"Console & Cartridge"** plugin system using ES Modules (`import`/`export`).

### Folder Structure
*   `src/core/`: Contains `GameInterface.js`, `ThemeManager.js`, `FirebaseManager.js`, `LeaderboardManager.js`.
*   `src/games/`: Modular game folders (e.g., `2048`).
*   `app.js`: The central router and lifecycle manager.
*   `ui/`: Global design tokens and shared components.
*   `src/games/2048/`: Photo 2048 with PixiJS v8 board rendering, HTML overlay UI, undo, quotes, coins, and leaderboard hooks.

### Adding a New Game
1.  Create `src/games/mygame/index.js`.
2.  Extend `GameInterface` and implement `mount()`, `start()`, and `pause()`.
3.  Register your game in `app.js`:
    ```javascript
    import { MyGame } from './src/games/mygame/index.js';
    const games = { 'mygame': new MyGame() };
    ```

## ðŸ† Leaderboards
*   Local scores live in `photo2048HighScores` (names cached in `arcadeCityPlayerName`).
*   Each entry saves `score`, `turns`, and `undos`.
*   2048 dispatches `game:over` with `{ score }`; `app.js` opens the glass sheet to capture/save.
*   The Scores button in the 2048 header opens the sheet; it shows â€œLive Firebase boardâ€ when cloud sync is active.

## âš ï¸ Current Scope
*   Only the 2048 cartridge is exposed in the UI; the bottom nav is hidden and coins display is suppressed until economy/city/shop are ready.
*   Settings are accessible via the header cog.
*   Mobile swipes are handled with pointer events on a full-height `.game-stage` surface (`touch-action: none`) so the dead space below the board still registers moves while header buttons remain tappable.
*   The 2048 board now renders via PixiJS v8 while header/overlays remain HTML.

## â˜ï¸ Firebase Integration (Leaderboards)
To enable online leaderboards:
1.  Create a project at [console.firebase.google.com](https://console.firebase.google.com/).
2.  Set `window.firebaseConfig = { ... }` before `app.js` runs (or call `window.FirebaseManager.configure(config);` after load).
3.  `FirebaseManager` pulls Firebase from the CDN, then `LeaderboardManager` will read/write to Firestore.
4.  If Firebase is unavailable, the UI automatically falls back to local scores.
5.  Firestore index: the query `where gameId == "2048"` + `orderBy score desc` needs a composite index. If you see â€œrequires an indexâ€ in the console, follow the provided link or create one with fields `gameId` (ASC) and `score` (DESC) on the `leaderboards` collection.

## ðŸ“œ Technical Docs
See [TDD.md](./TDD.md) for architectural details and [roadmap.md](./roadmap.md) for project status.
</file>

<file path="roadmap.md">
# Arcade City Roadmap

## Phase 1: Foundation (COMPLETED) âœ…
- [x] **Project Scaffolding:** Vite setup.
- [x] **UI System:** CSS Design tokens (Apple HIG style).
- [x] **Architecture:** Refactor to ES Modules (ESM) with `GameInterface`.
- [x] **Dev Workflow:** Local server integration via Vite.

## Phase 2: Game Modules (IN PROGRESS) ðŸ—ï¸
- [x] **2048 Module:** Ported to ESM structure.
- [x] **2048 Pixi Renderer:** Board rendering now uses PixiJS v8 with HTML overlays.
- [ ] **Match-3 Module:** Create placeholder cartridge.
- [ ] **Picross Module:** Create placeholder cartridge.

## Phase 3: Meta-Game (IN PROGRESS) ðŸ—ï¸
- [x] **City Engine:** PixiJS v8 basic isometric grid.
- [ ] **Interaction:** Move `CityScene.js` into a modular `src/games/city/` cartridge.
- [ ] **Building:** Implement building placement logic using inventory.

## Phase 4: Economy & Polish (PENDING) â³
- [x] **Economy:** Basic coin tracking.
- [x] **UI Polish:** Liquid Glass aesthetics, SF Symbols, Dark Mode.
- [x] **Leaderboard UI:** Glass sheet with local saves + name capture; documented reusable styles for mini buttons and cards.
- [x] **Input Polish:** Expanded 2048 swipe hitbox to full-height `.game-stage` using pointer events to remove dead zones on mobile.
- [ ] **Shop:** Connect JSON catalog to inventory persistence.
- [ ] **Cloud:** Enable Firebase leaderboards (client wiring ready; add `window.firebaseConfig` to activate).
- [ ] **PWA:** Service Worker caching for ESM assets.
- [ ] **Navigation gating:** City/shop views hidden until features are live; coins UI hidden pending economy UX.
- [ ] **Audio System:** Install Howler.js and implement `AudioManager` (global mute/sfx toggle).
- [ ] **Animation:** Install GSAP for Match-3 gem physics and UI transitions.
</file>

<file path="shop.json">
{
  "version": 1,
  "currency": "coins",
  "categories": [
    {
      "id": "cosmetics",
      "label": "Cosmetics",
      "priceTiers": [200, 400, 800, 1200],
      "items": [
        { "id": "cosmetic_hat_canvas", "name": "Canvas Cap", "price": 200, "type": "clothes" },
        { "id": "cosmetic_shirt_punk", "name": "Punk Jacket", "price": 400, "type": "clothes" },
        { "id": "cosmetic_shoes_runner", "name": "Runner Sneakers", "price": 800, "type": "clothes" },
        { "id": "cosmetic_costume_hero", "name": "Hero Costume", "price": 1200, "type": "clothes" }
      ]
    },
    {
      "id": "city",
      "label": "City",
      "priceTiers": [500, 900, 1500, 2400],
      "items": [
        { "id": "city_house_small", "name": "Small House", "price": 500, "type": "building", "footprint": { "w": 2, "h": 2 }, "sprite": "assets/city/svg/house.svg" },
        { "id": "city_bakery", "name": "Corner Bakery", "price": 900, "type": "building", "footprint": { "w": 3, "h": 2 }, "sprite": "assets/city/svg/shop.svg" },
        { "id": "city_park_fountain", "name": "Fountain Plaza", "price": 1500, "type": "decor", "footprint": { "w": 3, "h": 3 }, "sprite": "assets/city/svg/fountain.svg" },
        { "id": "city_townhall", "name": "Town Hall", "price": 2400, "type": "building", "footprint": { "w": 4, "h": 3 }, "sprite": "assets/city/svg/building_large.svg" },
        { "id": "city_road_tile", "name": "Road Tile", "price": 500, "type": "ground", "footprint": { "w": 1, "h": 1 }, "sprite": "assets/city/svg/road.svg", "groundType": "road" }
      ]
    }
  ]
}
</file>

<file path="src/core/FirebaseManager.js">
// Firebase Integration for leaderboards (CDN-based to avoid build-time deps)
export class FirebaseManager {
    constructor() {
        this.db = null;
        this.enabled = false;
        this.modules = null;
        this.config = null;
        this.initializing = null;
        this.indexRequired = false;
        this.indexLink = null;

        if (window.firebaseConfig) {
            this.configure(window.firebaseConfig);
        }
    }

    configure(config) {
        if (!config) return;
        this.config = config;
        if (!this.initializing) {
            this.initializing = this.init();
        }
        return this.initializing;
    }

    async init() {
        if (!this.config) {
            console.warn("Firebase config missing. Skipping init.");
            return;
        }

        try {
            const [appModule, firestoreModule] = await Promise.all([
                import('https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js'),
                import('https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js')
            ]);

            const app = appModule.initializeApp(this.config);
            const { getFirestore, collection, addDoc, query, orderBy, limit, getDocs, where, serverTimestamp } = firestoreModule;
            this.db = getFirestore(app);
            this.modules = { collection, addDoc, query, orderBy, limit, getDocs, where, serverTimestamp };
            this.enabled = true;
            console.info("Firebase initialized for leaderboards.");
        } catch (e) {
            this.enabled = false;
            this.initializing = null;
            console.warn("Firebase failed to load:", e);
        }
    }

    async submitScore(gameId, score, playerName, stats = {}) {
        if (!this.enabled || !this.db) return { ok: false, reason: "disabled" };
        try {
            const { collection, addDoc, serverTimestamp } = this.modules;
            await addDoc(collection(this.db, "leaderboards"), {
                gameId,
                score,
                playerName,
                turns: Math.max(0, Math.floor(stats.turns || 0)),
                undos: Math.max(0, Math.floor(stats.undos || 0)),
                timestamp: serverTimestamp ? serverTimestamp() : Date.now()
            });
            return { ok: true };
        } catch (e) {
            console.error("Error submitting score:", e);
            return { ok: false, reason: "network-error" };
        }
    }

    async getHighScores(gameId, limitCount = 10) {
        if (!this.enabled || !this.db) return [];
        try {
            const { collection, query, orderBy, limit, getDocs, where } = this.modules;
            const q = query(
                collection(this.db, "leaderboards"),
                where("gameId", "==", gameId),
                orderBy("score", "desc"),
                limit(limitCount)
            );
            const snapshot = await getDocs(q);
            return snapshot.docs.map((doc) => {
                const data = doc.data();
                return {
                    ...data,
                    turns: Math.max(0, Math.floor(data?.turns || 0)),
                    undos: Math.max(0, Math.floor(data?.undos || 0)),
                    timestamp: data?.timestamp?.toMillis ? data.timestamp.toMillis() : data.timestamp || Date.now()
                };
            });
        } catch (e) {
            this.indexRequired = e?.code === "failed-precondition";
            if (this.indexRequired && e?.message) {
                const match = e.message.match(/https?:\/\/[^\s]+/);
                this.indexLink = match ? match[0] : null;
                console.warn("Firestore index needed for leaderboard query.", this.indexLink || "");
            } else {
                console.error("Error fetching scores:", e);
            }
            return [];
        }
    }
}

// Global instance
window.FirebaseManager = new FirebaseManager();
</file>

<file path="src/core/GameInterface.js">
export class GameInterface {
    constructor(gameId) {
        this.gameId = gameId;
        this.container = null;
    }

    /**
     * Mounts the game into the provided DOM element.
     * @param {HTMLElement} container 
     */
    mount(container) {
        this.container = container;
    }

    /**
     * Starts the game loop or logic.
     */
    start() {}

    /**
     * Pauses the game (e.g., when switching tabs or views).
     */
    pause() {}

    /**
     * Resumes the game.
     */
    resume() {}

    /**
     * Cleans up resources, event listeners, and DOM elements.
     */
    destroy() {
        if (this.container) {
            this.container.innerHTML = '';
            this.container = null;
        }
    }
}
</file>

<file path="src/core/LeaderboardManager.js">
export class LeaderboardManager {
    constructor({ gameId, storageKey, limit = 20, firebaseManager } = {}) {
        this.gameId = gameId;
        this.storageKey = storageKey || `${gameId || "game"}HighScores`;
        this.limit = limit;
        this.firebaseManager = firebaseManager || null;
        this.cache = null;
    }

    normalizeScores(list, cap = this.limit) {
        const normalized = (list || []).map((entry) => {
            const turns = Math.max(0, Math.floor(entry.turns || entry.moves || 0));
            const undos = Math.max(0, Math.floor(entry.undos || entry.undo || 0));
            return {
                id: entry.id || `${Date.now().toString(36)}-${Math.random().toString(16).slice(2, 6)}`,
                name: (entry.name || entry.playerName || "Player").slice(0, 32),
                score: Math.max(0, Math.floor(entry.score || 0)),
                turns,
                undos,
                date: entry.date || entry.timestamp || Date.now(),
            };
        }).filter((entry) => Number.isFinite(entry.score));

        normalized.sort((a, b) => b.score - a.score || (a.date || 0) - (b.date || 0));
        return normalized.slice(0, cap);
    }

    loadLocalScores() {
        if (this.cache) return [...this.cache];
        try {
            const raw = localStorage.getItem(this.storageKey);
            const parsed = raw ? JSON.parse(raw) : [];
            this.cache = this.normalizeScores(parsed);
        } catch (error) {
            this.cache = [];
        }
        return [...this.cache];
    }

    persistLocal(scores) {
        this.cache = this.normalizeScores(scores);
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(this.cache));
        } catch (error) {
            // Ignore quota errors; best effort persistence
        }
        return [...this.cache];
    }

    clearLocal() {
        this.cache = [];
        try {
            localStorage.removeItem(this.storageKey);
        } catch (error) {
            // ignore
        }
    }

    isHighScore(score) {
        if (!Number.isFinite(score)) return false;
        const scores = this.loadLocalScores();
        if (scores.length < this.limit) return true;
        return score > scores[scores.length - 1].score;
    }

    addLocalScore(name, score, stats = {}) {
        const safeName = (name || "Player").trim().slice(0, 32) || "Player";
        const entry = {
            id: `${Date.now().toString(36)}-${Math.random().toString(16).slice(2, 8)}`,
            name: safeName,
            score: Math.max(0, Math.floor(score || 0)),
            turns: Math.max(0, Math.floor(stats.turns || 0)),
            undos: Math.max(0, Math.floor(stats.undos || 0)),
            date: Date.now(),
        };
        const next = this.normalizeScores([...this.loadLocalScores(), entry]);
        this.persistLocal(next);
        const rank = next.findIndex((item) => item.id === entry.id);
        return { rank: rank >= 0 ? rank + 1 : null, entry };
    }

    async submitScore(name, score, stats = {}) {
        if (!Number.isFinite(score)) {
            return { localRank: null, remote: { ok: false, reason: "invalid-score" } };
        }

        let localRank = null;
        if (this.isHighScore(score)) {
            const result = this.addLocalScore(name, score, stats);
            localRank = result.rank;
        }

        const remote = { ok: false, reason: "disabled" };
        if (this.firebaseManager && this.firebaseManager.enabled) {
            try {
                await this.firebaseManager.submitScore(this.gameId, score, name, stats);
                remote.ok = true;
                remote.reason = null;
            } catch (error) {
                remote.ok = false;
                remote.reason = "network-error";
            }
        }

        return { localRank, remote };
    }

    async fetchScores(limit = 10) {
        const local = this.loadLocalScores().slice(0, limit);
        let remote = [];

        if (this.firebaseManager && this.firebaseManager.enabled) {
            try {
                const result = await this.firebaseManager.getHighScores(this.gameId, limit);
                remote = this.normalizeScores(result || [], limit);
            } catch (error) {
                remote = [];
            }
        }

        return { local, remote };
    }
}
</file>

<file path="src/core/ThemeManager.js">
export class ThemeManager {
    constructor() {
        this.toggle = document.getElementById("theme-toggle");
        this.body = document.body;
        this.init();
    }

    init() {
        if (!this.toggle) return;

        // Check local storage or system preference
        const savedTheme = localStorage.getItem("arcadeCityTheme");
        const systemDark = window.matchMedia("(prefers-color-scheme: dark)").matches;

        if (savedTheme === "dark" || (!savedTheme && systemDark)) {
            this.enableDarkMode();
        }

        this.toggle.addEventListener("change", (e) => {
            if (e.target.checked) {
                this.enableDarkMode();
            } else {
                this.disableDarkMode();
            }
        });
    }

    enableDarkMode() {
        this.body.classList.add("dark-mode");
        if (this.toggle) this.toggle.checked = true;
        localStorage.setItem("arcadeCityTheme", "dark");
        this.updateMetaColor("#000000");
    }

    disableDarkMode() {
        this.body.classList.remove("dark-mode");
        if (this.toggle) this.toggle.checked = false;
        localStorage.setItem("arcadeCityTheme", "light");
        this.updateMetaColor("#F2F2F7");
    }

    updateMetaColor(color) {
        const meta = document.querySelector('meta[name="theme-color"]');
        if (meta) meta.setAttribute("content", color);
    }
}

// Auto-init
new ThemeManager();
</file>

<file path="src/games/2048/components/GameManager.js">
import { Grid } from './Grid.js';
import { Tile } from './Tile.js';

export class GameManager {
  constructor(size, InputManager, Actuator, StorageManager, callbacks = {}) {
    this.size = size;
    this.inputManager = new InputManager();
    this.storageManager = new StorageManager();
    
    this.actuator = Actuator instanceof Function ? new Actuator() : Actuator; 
    
    this.callbacks = callbacks;
    this.resultRecorded = false;
    this.undoState = null;
    this.turnCount = 0;
    this.undoCount = 0;

    this.startTiles = 2;

    this.inputManager.on("move", this.move.bind(this));
    this.inputManager.on("restart", this.restart.bind(this));
    this.inputManager.on("keepPlaying", this.keepPlaying.bind(this));
    this.inputManager.on("undo", this.undo.bind(this));

    this.setup();
  }

  destroy() {
    // Clean up input listeners to prevent double-firing events after restart
    if (this.inputManager && this.inputManager.destroy) {
        this.inputManager.destroy();
    }
  }

  restart() {
    if (this.callbacks.onRestart) {
        this.callbacks.onRestart();
    } else {
        this.reset();
    }
  }
  
  reset() {
    this.storageManager.clearGameState();
    this.storageManager.clearUndoState();
    this.actuator.continueGame(); 
    this.setup();
  }

  keepPlaying() {
    this.keepPlaying = true;
    this.actuator.continueGame(); 
  }

  isGameTerminated() {
    return this.over || (this.won && !this.keepPlaying);
  }

  setup() {
    var previousState = this.storageManager.getGameState();
    var storedUndoState = this.storageManager.getUndoState();
    const hasState = !!previousState;
    const gridHasTiles = (state) => {
      if (!state?.grid?.cells) return false;
      return state.grid.cells.some(col => col.some(cell => !!cell));
    };

    if (previousState && gridHasTiles(previousState)) {
      this.grid = new Grid(previousState.grid.size, previousState.grid.cells);
      this.score = previousState.score;
      this.over = previousState.over;
      this.won = previousState.won;
      this.keepPlaying = previousState.keepPlaying;
      this.resultRecorded = !!previousState.resultRecorded;
      this.undoState = storedUndoState;
      this.turnCount = previousState.turnCount || 0;
      this.undoCount = previousState.undoCount || 0;
    } else {
      this.storageManager.clearGameState();
      this.grid = new Grid(this.size);
      this.score = 0;
      this.over = false;
      this.won = false;
      this.keepPlaying = false;
      this.resultRecorded = false;
      this.undoState = null;
      this.turnCount = 0;
      this.undoCount = 0;
      this.storageManager.clearUndoState();
      this.addStartTiles();
    }

    if (this.callbacks.onEconomyRun) {
        this.callbacks.onEconomyRun(hasState);
    }

    this.actuate();
  }

  addStartTiles() {
    for (var i = 0; i < this.startTiles; i++) {
      this.addRandomTile();
    }
  }

  addRandomTile() {
    if (this.grid.cellsAvailable()) {
      var value = Math.random() < 0.9 ? 2 : 4;
      var tile = new Tile(this.grid.randomAvailableCell(), value);

      this.grid.insertTile(tile);
    }
  }

  actuate() {
    const shouldRecordResult = !this.resultRecorded && this.over;

    if (shouldRecordResult) {
      this.resultRecorded = true;
    }

    if (this.storageManager.getBestScore() < this.score) {
      this.storageManager.setBestScore(this.score);
    }

    if (this.over) {
      this.storageManager.clearGameState();
    } else {
      this.storageManager.setGameState(this.serialize());
    }

    if (this.callbacks.onScore) {
        this.callbacks.onScore(this.score);
    }

    this.actuator.actuate(this.grid, {
      score: this.score,
      over: this.over,
      won: this.won,
      bestScore: this.storageManager.getBestScore(),
      terminated: this.isGameTerminated(),
    });

    if (shouldRecordResult && this.callbacks.onGameEnd) {
      this.callbacks.onGameEnd(this.score, this.grid, this.getStats());
    }

    this.updateUndoAvailability();
  }

  serialize() {
    return {
      grid: this.grid.serialize(),
      score: this.score,
      over: this.over,
      won: this.won,
      keepPlaying: this.keepPlaying,
      resultRecorded: this.resultRecorded,
      turnCount: this.turnCount,
      undoCount: this.undoCount,
    };
  }

  setUndoState(state) {
    this.undoState = state || null;
    if (this.storageManager && this.storageManager.setUndoState) {
      this.storageManager.setUndoState(this.undoState);
    }
    this.updateUndoAvailability();
  }

  updateUndoAvailability() {
    if (this.actuator && this.actuator.setUndoAvailable) {
      this.actuator.setUndoAvailable(!!this.undoState);
    }
  }

  restoreState(state) {
    if (!state || !state.grid) return;

    this.grid = new Grid(state.grid.size, state.grid.cells);
    this.score = state.score;
    this.over = state.over;
    this.won = state.won;
    this.keepPlaying = state.keepPlaying;
    this.resultRecorded = !!state.resultRecorded;
    this.turnCount = state.turnCount || 0;
    this.undoCount = state.undoCount || 0;

    this.grid.eachCell((x, y, tile) => {
      if (tile) {
        tile.mergedFrom = null;
        tile.previousPosition = { x, y };
      }
    });

    this.actuator.continueGame();
    this.actuate();
  }

  undo() {
    if (!this.undoState) return;
    const previous = this.undoState;
    this.setUndoState(null);
    this.undoCount += 1;
    this.restoreState(previous);
    if (this.actuator && this.actuator.playUndoEffect) {
      this.actuator.playUndoEffect();
    }
  }

  prepareTiles() {
    this.grid.eachCell(function (x, y, tile) {
      if (tile) {
        tile.mergedFrom = null;
        tile.savePosition();
      }
    });
  }

  moveTile(tile, cell) {
    this.grid.cells[tile.x][tile.y] = null;
    this.grid.cells[cell.x][cell.y] = tile;
    tile.updatePosition(cell);
  }

  move(direction) {
    var self = this;

    if (this.isGameTerminated()) return;

    var previousState = this.serialize();

    var cell, tile;

    var vector = this.getVector(direction);
    var traversals = this.buildTraversals(vector);
    var moved = false;

    this.prepareTiles();

    traversals.x.forEach(function (x) {
      traversals.y.forEach(function (y) {
        cell = { x: x, y: y };
        tile = self.grid.cellContent(cell);

        if (tile) {
          var positions = self.findFarthestPosition(cell, vector);
          var next = self.grid.cellContent(positions.next);

          if (next && next.value === tile.value && !next.mergedFrom) {
            var merged = new Tile(positions.next, tile.value * 2);
            merged.mergedFrom = [tile, next];

            self.grid.insertTile(merged);
            self.grid.removeTile(tile);

            tile.updatePosition(positions.next);

            self.score += merged.value;

            if (merged.value === 2048) {
              self.won = true;
            }
          } else {
            self.moveTile(tile, positions.farthest);
          }

          if (!self.positionsEqual(cell, tile)) {
            moved = true;
          }
        }
      });
    });

    if (moved) {
      this.setUndoState(previousState);
      this.addRandomTile();
      this.turnCount += 1;

      if (!this.movesAvailable()) {
        this.over = true;
      }

      this.actuate();
    }
  }

  getVector(direction) {
    var map = {
      0: { x: 0, y: -1 }, // Up
      1: { x: 1, y: 0 }, // Right
      2: { x: 0, y: 1 }, // Down
      3: { x: -1, y: 0 }, // Left
    };

    return map[direction];
  }

  buildTraversals(vector) {
    var traversals = { x: [], y: [] };

    for (var pos = 0; pos < this.size; pos++) {
      traversals.x.push(pos);
      traversals.y.push(pos);
    }

    if (vector.x === 1) traversals.x = traversals.x.reverse();
    if (vector.y === 1) traversals.y = traversals.y.reverse();

    return traversals;
  }

  findFarthestPosition(cell, vector) {
    var previous;

    do {
      previous = cell;
      cell = { x: previous.x + vector.x, y: previous.y + vector.y };
    } while (this.grid.withinBounds(cell) && this.grid.cellAvailable(cell));

      return {
        farthest: previous,
        next: cell,
      };
    }

    getStats() {
      return {
        turns: this.turnCount,
        undos: this.undoCount,
      };
    }

  movesAvailable() {
    return this.grid.cellsAvailable() || this.tileMatchesAvailable();
  }

  tileMatchesAvailable() {
    var self = this;
    var tile;

    for (var x = 0; x < this.size; x++) {
      for (var y = 0; y < this.size; y++) {
        tile = this.grid.cellContent({ x: x, y: y });

        if (tile) {
          for (var direction = 0; direction < 4; direction++) {
            var vector = self.getVector(direction);
            var cell = { x: x + vector.x, y: y + vector.y };

            var other = self.grid.cellContent(cell);

            if (other && other.value === tile.value) {
              return true;
            }
          }
        }
      }
    }

    return false;
  }

  positionsEqual(first, second) {
    return first.x === second.x && first.y === second.y;
  }
}
</file>

<file path="src/games/2048/components/Grid.js">
import { Tile } from './Tile.js';

export class Grid {
  constructor(size, previousState) {
    this.size = size;
    this.cells = previousState ? this.fromState(previousState) : this.empty();
  }

  // Build a grid of the specified size
  empty() {
    var cells = [];

    for (var x = 0; x < this.size; x++) {
      var row = (cells[x] = []);

      for (var y = 0; y < this.size; y++) {
        row.push(null);
      }
    }

    return cells;
  }

  fromState(state) {
    var cells = [];

    for (var x = 0; x < this.size; x++) {
      var row = (cells[x] = []);

      for (var y = 0; y < this.size; y++) {
        var tile = state[x][y];
        row.push(tile ? new Tile(tile.position, tile.value) : null);
      }
    }

    return cells;
  }

  // Find the first available random position
  randomAvailableCell() {
    var cells = this.availableCells();

    if (cells.length) {
      return cells[Math.floor(Math.random() * cells.length)];
    }
  }

  availableCells() {
    var cells = [];

    this.eachCell(function (x, y, tile) {
      if (!tile) {
        cells.push({ x: x, y: y });
      }
    });

    return cells;
  }

  eachCell(callback) {
    for (var x = 0; x < this.size; x++) {
      for (var y = 0; y < this.size; y++) {
        callback(x, y, this.cells[x][y]);
      }
    }
  }

  cellsAvailable() {
    return !!this.availableCells().length;
  }

  cellAvailable(cell) {
    return !this.cellContent(cell);
  }

  cellContent(cell) {
    if (this.withinBounds(cell)) {
      return this.cells[cell.x][cell.y];
    } else {
      return null;
    }
  }

  insertTile(tile) {
    this.cells[tile.x][tile.y] = tile;
  }

  removeTile(tile) {
    this.cells[tile.x][tile.y] = null;
  }

  withinBounds(position) {
    return (
      position.x >= 0 &&
      position.x < this.size &&
      position.y >= 0 &&
      position.y < this.size
    );
  }

  serialize() {
    var cellState = [];

    for (var x = 0; x < this.size; x++) {
      var row = (cellState[x] = []);

      for (var y = 0; y < this.size; y++) {
        row.push(this.cells[x][y] ? this.cells[x][y].serialize() : null);
      }
    }

    return {
      size: this.size,
      cells: cellState,
    };
  }
}
</file>

<file path="src/games/2048/components/HTMLActuator.js">
export class HTMLActuator {
  constructor(container) {
    this.container = container;
    this.tileContainer = container.querySelector(".tile-container");
    this.scoreContainer = container.querySelector(".score-container");
    this.bestContainer = container.querySelector(".best-container");
    this.messageContainer = container.querySelector(".game-message");
    this.gameContainer = container.querySelector(".game-container");
    this.undoButton = container.querySelector("#undo-button");
    this.keepPlayingButton = container.querySelector(".keep-playing-button");
    this.retryButton = container.querySelector(".retry-button");

    this.score = 0;
    this.undoEffectTimeout = null;

  }

  actuate(grid, metadata) {
    var self = this;

    window.requestAnimationFrame(function () {
      self.clearContainer(self.tileContainer);

      grid.cells.forEach(function (column) {
        column.forEach(function (cell) {
          if (cell) {
            self.addTile(cell);
          }
        });
      });

      self.updateScore(metadata.score);
      self.updateBestScore(metadata.bestScore);

      if (metadata.terminated) {
        if (metadata.over) {
          self.message(false); // You lose
        } else if (metadata.won) {
          self.message(true); // You win!
        }
      }
    });
  }

  continueGame() {
    this.clearMessage();
  }

  clearContainer(container) {
    while (container.firstChild) {
      container.removeChild(container.firstChild);
    }
  }

  addTile(tile) {
    var self = this;

    var wrapper = document.createElement("div");
    var inner = document.createElement("div");
    var position = tile.previousPosition || { x: tile.x, y: tile.y };
    var positionClass = this.positionClass(position);

    // We can't use classList because it somehow glitches when replacing classes
    var classes = ["tile", "tile-" + tile.value, positionClass];

    if (tile.value > 2048) classes.push("tile-super");

    this.applyClasses(wrapper, classes);

    inner.classList.add("tile-inner");
    inner.textContent = tile.value; 
    
    const CustomImages = window.CustomImages || {};
    const customImageAvailability = window.customImageAvailability || {};

    // Set custom background image if available
    if (CustomImages[tile.value] && customImageAvailability[tile.value]) {
      inner.style.backgroundImage = `url('${CustomImages[tile.value]}')`;
      inner.classList.add("has-image");
      inner.textContent = ""; // Clear text if image is used
    }

    if (tile.previousPosition) {
      // Make sure that the tile gets rendered in the previous position first
      // We use a small timeout to ensure the browser has time to paint the initial state
      // or double RAF to ensure next frame.
      window.requestAnimationFrame(function () {
        window.requestAnimationFrame(function() {
          classes[2] = self.positionClass({ x: tile.x, y: tile.y });
          self.applyClasses(wrapper, classes); // Update the position
        });
      });
    } else if (tile.mergedFrom) {
      classes.push("tile-merged");
      
      // Add specific merged classes for high values to trigger cool animations
      if (tile.value >= 64) {
        classes.push("tile-merged-effect");
        classes.push("tile-merged-" + tile.value);
      }

      this.applyClasses(wrapper, classes);

      // Render the tiles that merged
      tile.mergedFrom.forEach(function (merged) {
        self.addTile(merged);
      });
    } else {
      classes.push("tile-new");
      this.applyClasses(wrapper, classes);
    }

    wrapper.appendChild(inner);

    // Add the inner part to the wrapper
    this.tileContainer.appendChild(wrapper);

    if (tile.mergedFrom && window.effectManager) {
      window.requestAnimationFrame(() => {
        window.effectManager.explode(wrapper, tile.value);
      });
    }
  }

  applyClasses(element, classes) {
    element.setAttribute("class", classes.join(" "));
  }

  normalizePosition(position) {
    return { x: position.x + 1, y: position.y + 1 };
  }

  positionClass(position) {
    position = this.normalizePosition(position);
    return "tile-position-" + position.x + "-" + position.y;
  }

  updateScore(score) {
    var difference = score - this.score;
    this.score = score;

    const valueEl = this.scoreContainer.querySelector(".score-value");
    if (valueEl) {
      valueEl.textContent = this.score;
    } else {
      this.scoreContainer.textContent = this.score;
    }

    if (difference > 0) {
      var addition = document.createElement("div");
      addition.classList.add("score-addition");
      addition.textContent = "+" + difference;

      this.scoreContainer.appendChild(addition);
    }
  }

  updateBestScore(bestScore) {
    const valueEl = this.bestContainer.querySelector(".score-value");
    if (valueEl) {
      valueEl.textContent = bestScore;
    } else {
      this.bestContainer.textContent = bestScore;
    }
  }

  setElementVisible(el, isVisible) {
    if (!el) return;
    el.classList.toggle("hidden", !isVisible);
  }

  message(won) {
    var type = won ? "game-won" : "game-over";
    var message = won ? "You win!" : "Game over!";

    this.messageContainer.classList.remove("hidden");
    this.messageContainer.classList.remove(won ? "game-over" : "game-won");
    this.messageContainer.classList.add(type);
    this.messageContainer.getElementsByTagName("p")[0].textContent = message;

    this.setElementVisible(this.keepPlayingButton, !!won);
    this.setElementVisible(this.retryButton, true);

    // For losses, rely on leaderboard overlay; hide this panel to avoid stacking
    if (!won) {
      this.messageContainer.classList.add("hidden");
    }
  }

  clearMessage() {
    this.messageContainer.classList.remove("game-won");
    this.messageContainer.classList.remove("game-over");
    this.messageContainer.classList.remove("hidden");
    this.setElementVisible(this.keepPlayingButton, true);
    this.setElementVisible(this.retryButton, true);
  }

  setUndoAvailable(isAvailable) {
    if (!this.undoButton) return;
    this.undoButton.disabled = !isAvailable;
  }

  playUndoEffect() {
    if (this.gameContainer) {
      this.gameContainer.classList.remove("undo-flash");
      void this.gameContainer.offsetWidth;
      this.gameContainer.classList.add("undo-flash");
      if (this.undoEffectTimeout) {
        window.clearTimeout(this.undoEffectTimeout);
      }
      this.undoEffectTimeout = window.setTimeout(() => {
        if (this.gameContainer) {
          this.gameContainer.classList.remove("undo-flash");
        }
        this.undoEffectTimeout = null;
      }, 280);
    }

    if (window.effectManager && window.effectManager.rewind) {
      // Lighter rewind for mobile; skip heavy particles if container is small
      if (this.gameContainer && this.gameContainer.offsetWidth < 420) {
        return;
      }
      window.effectManager.rewind();
    }
  }
}
</file>

<file path="src/games/2048/components/KeyboardInputManager.js">
export class KeyboardInputManager {
  constructor() {
    this.events = {};

    // Use pointer events for unified handling
    this.eventTouchstart = "pointerdown";
    this.eventTouchmove = "pointermove";
    this.eventTouchend = "pointerup";

    // Bind methods to 'this' so they can be added/removed correctly
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.handleTouchStart = this.handleTouchStart.bind(this);
    this.handleTouchMove = this.handleTouchMove.bind(this);
    this.handleTouchEnd = this.handleTouchEnd.bind(this);
    this.handleTouchCancel = this.handleTouchCancel.bind(this);
    this.restart = this.restart.bind(this);
    this.undo = this.undo.bind(this);
    this.keepPlaying = this.keepPlaying.bind(this);

    // State for Swipe detection
    this.touchStartClientX = 0;
    this.touchStartClientY = 0;
    this.hasSwiped = false;
    this.gameContainer = null;

    this.listen();
  }

  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }

  emit(event, data) {
    var callbacks = this.events[event];
    if (callbacks) {
      callbacks.forEach(function (callback) {
        callback(data);
      });
    }
  }

  listen() {
    // 1. Keydown Events
    document.addEventListener("keydown", this.handleKeyDown);

    // 2. Button Events
    this.bindButtonPress(".restart-button", this.restart);
    this.bindButtonPress(".undo-button", this.undo);
    this.bindButtonPress(".keep-playing-button", this.keepPlaying);

    // 3. Swipe Events
    this.gameContainer = document.querySelector(".game-stage") || document.getElementsByClassName("game-container")[0];
    
    if (!this.gameContainer) return;

    const listenerOpts = { passive: false };

    // Ensure the container accepts touch/pointer events
    this.gameContainer.style.touchAction = "none";
    this.gameContainer.style.pointerEvents = "auto";

    this.gameContainer.addEventListener(this.eventTouchstart, this.handleTouchStart, listenerOpts);
    this.gameContainer.addEventListener(this.eventTouchmove, this.handleTouchMove, listenerOpts);
    this.gameContainer.addEventListener(this.eventTouchend, this.handleTouchEnd, listenerOpts);
    this.gameContainer.addEventListener("touchcancel", this.handleTouchCancel, listenerOpts);
  }

  destroy() {
    // Remove Keydown
    document.removeEventListener("keydown", this.handleKeyDown);

    // Remove Buttons (Selectors might reference new DOM elements if mounted again, but good practice)
    this.unbindButtonPress(".restart-button", this.restart);
    this.unbindButtonPress(".undo-button", this.undo);
    this.unbindButtonPress(".keep-playing-button", this.keepPlaying);

    // Remove Swipe Events
    if (this.gameContainer) {
      const listenerOpts = { passive: false };
      this.gameContainer.removeEventListener(this.eventTouchstart, this.handleTouchStart, listenerOpts);
      this.gameContainer.removeEventListener(this.eventTouchmove, this.handleTouchMove, listenerOpts);
      this.gameContainer.removeEventListener(this.eventTouchend, this.handleTouchEnd, listenerOpts);
      this.gameContainer.removeEventListener("touchcancel", this.handleTouchCancel, listenerOpts);
      this.gameContainer = null;
    }
    
    this.events = {};
  }

  // --- Event Handlers ---

  handleKeyDown(event) {
    const map = {
      38: 0, // Up
      39: 1, // Right
      40: 2, // Down
      37: 3, // Left
      75: 0, // Vim up
      76: 1, // Vim right
      74: 2, // Vim down
      72: 3, // Vim left
      87: 0, // W
      68: 1, // D
      83: 2, // S
      65: 3, // A
    };

    if (this.isTypingTarget(event.target) || this.isOverlayActive()) {
      return;
    }

    var modifiers = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;
    var mapped = map[event.which];

    if (!modifiers) {
      if (mapped !== undefined) {
        event.preventDefault();
        this.emit("move", mapped);
      }
    }

    if (!modifiers && event.which === 85) {
      event.preventDefault();
      this.emit("undo");
    }

    // R key restarts the game
    if (!modifiers && event.which === 82) {
      this.restart(event);
    }
  }

  handleTouchStart(event) {
    if (event.pointerType === "touch" && event.isPrimary === false) return;

    this.touchStartClientX = event.clientX;
    this.touchStartClientY = event.clientY;
    this.hasSwiped = false;
    // Do not strictly prevent default here, sometimes needed for scrolling? 
    // But for games usually yes.
    event.preventDefault(); 
  }

  handleTouchMove(event) {
    event.preventDefault();

    if (this.hasSwiped) return;
    if (event.pointerType === "touch" && event.isPrimary === false) return;

    var touchEndClientX = event.clientX;
    var touchEndClientY = event.clientY;

    var dx = touchEndClientX - this.touchStartClientX;
    var dy = touchEndClientY - this.touchStartClientY;
    var absDx = Math.abs(dx);
    var absDy = Math.abs(dy);

    if (Math.max(absDx, absDy) > 6) {
      // (right : left) : (down : up)
      this.emit("move", absDx > absDy ? (dx > 0 ? 1 : 3) : dy > 0 ? 2 : 0);
      this.hasSwiped = true;
    }
  }

  handleTouchEnd(event) {
    if (event.pointerType === "touch" && event.isPrimary === false) return;
    if (this.hasSwiped) return;

    // Optional: Logic for tap vs swipe end could go here
    // For now we rely on move to trigger the swipe
  }

  handleTouchCancel(event) {
    this.hasSwiped = false;
  }

  // --- Helpers ---

  isTypingTarget(target) {
    if (!target) return false;
    if (target.isContentEditable) return true;
    var tag = target.tagName;
    return tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT";
  }

  isOverlayActive() {
    var leaderboard = document.getElementById("leaderboard");
    if (leaderboard && !leaderboard.classList.contains("hidden")) return true;
    var themeSelector = document.getElementById("theme-selector");
    if (themeSelector && !themeSelector.classList.contains("hidden")) return true;
    return false;
  }

  restart(event) {
    if (event) event.preventDefault();
    this.emit("restart");
  }

  undo(event) {
    if (event) event.preventDefault();
    this.emit("undo");
  }

  keepPlaying(event) {
    if (event) event.preventDefault();
    this.emit("keepPlaying");
  }

  bindButtonPress(selector, fn) {
    var button = document.querySelector(selector);
    if (!button) return;
    button.addEventListener("click", fn);
    button.addEventListener(this.eventTouchend, fn);
  }
  
  unbindButtonPress(selector, fn) {
    var button = document.querySelector(selector);
    if (!button) return;
    button.removeEventListener("click", fn);
    button.removeEventListener(this.eventTouchend, fn);
  }
}
</file>

<file path="src/games/2048/components/LocalStorageManager.js">
export class LocalStorageManager {
  constructor() {
    this.bestScoreKey = "bestScore";
    this.gameStateKey = "gameState";
    this.undoStateKey = "undoState";
    var supported = this.localStorageSupported();
    this.storage = supported ? window.localStorage : window.fakeStorage;
  }

  localStorageSupported() {
    var testKey = "test";
    var storage = window.localStorage;

    try {
      storage.setItem(testKey, "1");
      storage.removeItem(testKey);
      return true;
    } catch (error) {
      return false;
    }
  }

  getBestScore() {
    return this.storage.getItem(this.bestScoreKey) || 0;
  }

  setBestScore(score) {
    this.storage.setItem(this.bestScoreKey, score);
  }

  getGameState() {
    var stateJSON = this.storage.getItem(this.gameStateKey);
    return stateJSON ? JSON.parse(stateJSON) : null;
  }

  setGameState(gameState) {
    this.storage.setItem(this.gameStateKey, JSON.stringify(gameState));
  }

  clearGameState() {
    this.storage.removeItem(this.gameStateKey);
  }

  getUndoState() {
    var stateJSON = this.storage.getItem(this.undoStateKey);
    if (!stateJSON) return null;
    try {
      return JSON.parse(stateJSON);
    } catch (error) {
      return null;
    }
  }

  setUndoState(undoState) {
    if (!undoState) {
      this.storage.removeItem(this.undoStateKey);
      return;
    }
    this.storage.setItem(this.undoStateKey, JSON.stringify(undoState));
  }

  clearUndoState() {
    this.storage.removeItem(this.undoStateKey);
  }
}

window.fakeStorage = {
  _data: {},

  setItem: function (id, val) {
    return (this._data[id] = String(val));
  },

  getItem: function (id) {
    return this._data.hasOwnProperty(id) ? this._data[id] : undefined;
  },

  removeItem: function (id) {
    return delete this._data[id];
  },

  clear: function () {
    return (this._data = {});
  },
};
</file>

<file path="src/games/2048/components/PixiActuator.js">
export class PixiActuator {
  constructor(container, boardRenderer) {
    this.container = container;
    this.boardRenderer = boardRenderer;
    this.scoreContainer = container.querySelector(".score-container");
    this.bestContainer = container.querySelector(".best-container");
    this.messageContainer = container.querySelector(".game-message");
    this.gameContainer = container.querySelector(".game-container");
    this.undoButton = container.querySelector("#undo-button");
    this.keepPlayingButton = container.querySelector(".keep-playing-button");
    this.retryButton = container.querySelector(".retry-button");

    this.score = 0;
    this.undoEffectTimeout = null;
  }

  actuate(grid, metadata) {
    if (this.boardRenderer) {
      this.boardRenderer.update(grid);
    }

    this.updateScore(metadata.score);
    this.updateBestScore(metadata.bestScore);

    if (metadata.terminated) {
      if (metadata.over) {
        this.message(false);
      } else if (metadata.won) {
        this.message(true);
      }
    }
  }

  continueGame() {
    this.clearMessage();
  }

  updateScore(score) {
    const difference = score - this.score;
    this.score = score;

    const valueEl = this.scoreContainer.querySelector(".score-value");
    if (valueEl) {
      valueEl.textContent = this.score;
    } else {
      this.scoreContainer.textContent = this.score;
    }

    if (difference > 0) {
      const addition = document.createElement("div");
      addition.classList.add("score-addition");
      addition.textContent = "+" + difference;
      this.scoreContainer.appendChild(addition);

      // Clean up the element after the animation completes to prevent DOM piling
      addition.addEventListener('animationend', () => {
        if (addition.parentNode) {
            addition.parentNode.removeChild(addition);
        }
      });
    }
  }

  updateBestScore(bestScore) {
    const valueEl = this.bestContainer.querySelector(".score-value");
    if (valueEl) {
      valueEl.textContent = bestScore;
    } else {
      this.bestContainer.textContent = bestScore;
    }
  }

  setElementVisible(el, isVisible) {
    if (!el) return;
    el.classList.toggle("hidden", !isVisible);
  }

  message(won) {
    if (!won) return;
    const type = won ? "game-won" : "game-over";
    const message = won ? "You win!" : "Wasted";

    this.messageContainer.classList.remove("hidden");
    this.messageContainer.classList.remove(won ? "game-over" : "game-won");
    this.messageContainer.classList.add(type);
    this.messageContainer.getElementsByTagName("p")[0].textContent = message;

    this.setElementVisible(this.keepPlayingButton, !!won);
    this.setElementVisible(this.retryButton, true);
  }

  clearMessage() {
    this.messageContainer.classList.remove("game-won");
    this.messageContainer.classList.remove("game-over");
    this.messageContainer.classList.remove("hidden");
    this.setElementVisible(this.keepPlayingButton, true);
    this.setElementVisible(this.retryButton, true);
  }

  setUndoAvailable(isAvailable) {
    if (!this.undoButton) return;
    this.undoButton.disabled = !isAvailable;
  }

  playUndoEffect() {
    if (this.gameContainer) {
      this.gameContainer.classList.remove("undo-flash");
      void this.gameContainer.offsetWidth;
      this.gameContainer.classList.add("undo-flash");
      if (this.undoEffectTimeout) {
        window.clearTimeout(this.undoEffectTimeout);
      }
      this.undoEffectTimeout = window.setTimeout(() => {
        if (this.gameContainer) {
          this.gameContainer.classList.remove("undo-flash");
        }
        this.undoEffectTimeout = null;
      }, 280);
    }

    if (window.effectManager && window.effectManager.rewind) {
      if (this.gameContainer && this.gameContainer.offsetWidth < 420) {
        return;
      }
      window.effectManager.rewind();
    }
  }

  showGameOverQuote() {
    // No-op for Pixi renderer
  }
}
</file>

<file path="src/games/2048/components/PixiBoardRenderer.js">
import { Application, Container, Graphics, Sprite, Text, Texture } from 'pixi.js';

const TILE_COLORS = {
  2: 0xeee4da,
  4: 0xede0c8,
  8: 0xf2b179,
  16: 0xf59563,
  32: 0xf67c5f,
  64: 0xf65e3b,
  128: 0xedcf72,
  256: 0xedcc61,
  512: 0xedc850,
  1024: 0xedc53f,
  2048: 0xedc22e,
};

const DARK_TEXT = 0x776e65;
const LIGHT_TEXT = 0xf9f6f2;

// --- CRITICAL FIX 1: Use Quintic Easing (Much snappier/smoother) ---
const easeOutQuint = (t) => 1 - Math.pow(1 - t, 5);

export class PixiBoardRenderer {
  constructor(hostEl, options = {}) {
    this.hostEl = hostEl;
    this.size = options.size || 4;
    this.imageAvailability = options.imageAvailability || {};
    this.imagePaths = options.imagePaths || {};
    this.textures = new Map();
    this.tiles = new Map();
    this.tweens = new Set();
    this.metrics = {
      tileSize: 0,
      spacing: 0,
      offsetX: 0,
      offsetY: 0,
      boardSize: 0,
      radius: 0,
    };
    this.pendingGrid = null;
    this.resizeObserver = null;
    this.themeObserver = null;
    this.ready = this.init();
  }

  async init() {
    if (!this.hostEl) return;

    this.app = new Application();
    await this.app.init({
      backgroundAlpha: 0,
      antialias: true,
      resizeTo: this.hostEl,
    });

    // PixiJS v8 uses .canvas, not .view
    this.app.canvas.classList.add('pixi-board');
    this.app.canvas.style.width = '100%';
    this.app.canvas.style.height = '100%';
    this.app.canvas.style.pointerEvents = 'none';

    this.hostEl.innerHTML = '';
    this.hostEl.appendChild(this.app.canvas);

    this.root = new Container();
    this.backgroundLayer = new Container();
    this.tileLayer = new Container();
    this.tileLayer.sortableChildren = true;
    this.root.addChild(this.backgroundLayer);
    this.root.addChild(this.tileLayer);
    this.app.stage.addChild(this.root);

    this.app.ticker.add(this.updateTweens, this);

    if (typeof ResizeObserver !== 'undefined') {
      this.resizeObserver = new ResizeObserver(() => this.resize());
      this.resizeObserver.observe(this.hostEl);
    } else {
      window.addEventListener('resize', () => this.resize());
    }

    this.observeTheme();
    this.resize();

    if (this.pendingGrid) {
      const grid = this.pendingGrid;
      this.pendingGrid = null;
      this.update(grid);
    }
  }

  observeTheme() {
    if (typeof MutationObserver === 'undefined' || !document.body) return;
    this.themeObserver = new MutationObserver(() => this.drawBackground());
    this.themeObserver.observe(document.body, { attributes: true, attributeFilter: ['class'] });
  }

  setThemeAssets(imagePaths, imageAvailability) {
    this.imagePaths = imagePaths || {};
    this.imageAvailability = imageAvailability || {};
    this.textures.clear();
    this.refreshTiles();
  }

  setTileTexture(value, image) {
    if (!image) return;
    const texture = image instanceof Texture ? image : Texture.from(image);
    this.textures.set(value, texture);
    this.refreshTileValue(value);
  }

  resize() {
    if (!this.hostEl) return;
    const width = this.hostEl.clientWidth;
    const height = this.hostEl.clientHeight;
    if (!width || !height) return;

    const boardSize = Math.min(width, height);
    const spacing = Math.max(6, Math.round(boardSize * 0.025));
    const tileSize = Math.floor((boardSize - spacing * (this.size + 1)) / this.size);
    const actualBoard = tileSize * this.size + spacing * (this.size + 1);
    const offsetX = (width - actualBoard) / 2;
    const offsetY = (height - actualBoard) / 2;
    const radius = Math.max(6, Math.round(tileSize * 0.1));

    this.metrics = {
      tileSize,
      spacing,
      offsetX,
      offsetY,
      boardSize: actualBoard,
      radius,
    };

    this.drawBackground();
    this.refreshTiles();
  }

  drawBackground() {
    if (!this.backgroundLayer) return;
    this.backgroundLayer.removeChildren();
    const grid = new Graphics();
    const { tileSize, spacing } = this.metrics;
    const { radius } = this.metrics;

    const isDark = document.body.classList.contains('dark-mode');
    const color = isDark ? 0xffffff : 0x999999;
    const alpha = isDark ? 0.06 : 0.15;

    for (let x = 0; x < this.size; x += 1) {
      for (let y = 0; y < this.size; y += 1) {
        const pos = this.getCellPosition(x, y);
        grid.roundRect(pos.x, pos.y, tileSize, tileSize, radius * 0.8);
        grid.fill({ color, alpha });
      }
    }

    this.backgroundLayer.addChild(grid);
  }

  getCellPosition(x, y) {
    const { spacing, tileSize, offsetX, offsetY } = this.metrics;
    return {
      x: offsetX + spacing + x * (tileSize + spacing),
      y: offsetY + spacing + y * (tileSize + spacing),
    };
  }

  getContainerPosition(x, y) {
    const pos = this.getCellPosition(x, y);
    const { tileSize } = this.metrics;
    return {
      x: pos.x + tileSize / 2,
      y: pos.y + tileSize / 2,
    };
  }

  update(grid) {
    if (!this.app) {
      this.pendingGrid = grid;
      return;
    }

    const toRemove = new Set(this.tiles.keys());

    grid.eachCell((x, y, tile) => {
      if (!tile) return;
      toRemove.delete(tile);
      if (this.tiles.has(tile)) {
        this.updateTile(tile);
      } else {
        this.addTile(tile, toRemove);
      }
    });

    toRemove.forEach((tile) => this.removeTile(tile));
  }

  addTile(tile, toRemove) {
    const container = new Container();
    this.renderTileVisual(container, tile.value);
    this.tileLayer.addChild(container);
    this.tiles.set(tile, container);

    const dest = this.getContainerPosition(tile.x, tile.y);
    this.setTilePivot(container);

    if (tile.previousPosition) {
      const prev = this.getContainerPosition(tile.previousPosition.x, tile.previousPosition.y);
      container.position.set(prev.x, prev.y);
      this.animatePosition(container, dest);
    } else {
      container.position.set(dest.x, dest.y);
    }

    if (tile.mergedFrom && tile.mergedFrom.length) {
      container.scale.set(0);
      this.animateScale(container, 1);
      if (window.effectManager && window.effectManager.explodeAt) {
        window.effectManager.explodeAt(dest.x, dest.y, tile.value);
      }
      tile.mergedFrom.forEach((merged) => {
        const mergedContainer = this.tiles.get(merged);
        if (!mergedContainer) return;
        if (toRemove) {
          toRemove.delete(merged);
        }
        this.tiles.delete(merged);
        this.animatePosition(mergedContainer, dest, () => {
          mergedContainer.destroy({ children: true });
        });
      });
    } else if (!tile.previousPosition) {
      container.scale.set(0);
      this.animateScale(container, 1);
    }
  }

  updateTile(tile) {
    const container = this.tiles.get(tile);
    if (!container) return;
    const dest = this.getContainerPosition(tile.x, tile.y);
    this.setTilePivot(container);

    if (
      tile.previousPosition &&
      (tile.previousPosition.x !== tile.x || tile.previousPosition.y !== tile.y)
    ) {
      const prev = this.getContainerPosition(tile.previousPosition.x, tile.previousPosition.y);
      container.position.set(prev.x, prev.y);
      this.animatePosition(container, dest);
    } else {
      container.position.set(dest.x, dest.y);
    }
  }

  removeTile(tile) {
    const container = this.tiles.get(tile);
    if (!container) return;
    this.tiles.delete(tile);
    container.destroy({ children: true });
  }

  animatePosition(container, dest, onComplete) {
    this.removeTweens(container.position);
    // 100ms = Snappy speed
    // easeOutQuint = Smooth "Apple-like" arrival
    this.tweenTo(container.position, { x: dest.x, y: dest.y }, 65, easeOutQuint, onComplete);
  }

  animateScale(container, scale) {
    this.removeTweens(container.scale);
    // Scale can keep the bounce effect if you like, or match quint for consistency
    const easeBack = (t) => {
        const c1 = 1.70158;
        const c3 = c1 + 1;
        return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
    };
    this.tweenTo(container.scale, { x: scale, y: scale }, 140, easeBack);
  }

  setTilePivot(container) {
    const { tileSize } = this.metrics;
    container.pivot.set(tileSize / 2, tileSize / 2);
  }

  renderTileVisual(container, value) {
    const { tileSize, radius } = this.metrics;
    container.removeChildren();
    container.mask = null; 

    const texture = this.textures.get(value);
    const hasImage = this.imageAvailability[value] && texture;

    if (hasImage) {
      const sprite = new Sprite(texture);
      
      // Aspect Fill Logic (Fixes distortion)
      const scale = Math.max(tileSize / texture.width, tileSize / texture.height);
      sprite.scale.set(scale);
      sprite.anchor.set(0.5);
      sprite.position.set(tileSize / 2, tileSize / 2);
      
      const mask = new Graphics();
      mask.roundRect(0, 0, tileSize, tileSize, radius);
      mask.fill(0xffffff);
      
      container.addChild(sprite);
      container.addChild(mask);
      container.mask = mask; 
      return;
    }

    const bg = new Graphics();
    const color = TILE_COLORS[value] || 0x3c3a32;
    bg.roundRect(0, 0, tileSize, tileSize, radius);
    bg.fill(color);
    container.addChild(bg);

    const textColor = value <= 4 ? DARK_TEXT : LIGHT_TEXT;
    const text = new Text({
      text: String(value),
      style: {
        fontFamily: '"SF Pro Display", "SF Pro Text", "Helvetica Neue", Arial, sans-serif',
        fontWeight: '700',
        fontSize: this.getFontSize(value, tileSize),
        fill: textColor,
      },
    });
    text.anchor.set(0.5);
    text.position.set(tileSize / 2, tileSize / 2);
    container.addChild(text);
  }

  getFontSize(value, tileSize) {
    const digits = String(value).length;
    if (digits <= 2) return Math.round(tileSize * 0.45);
    if (digits === 3) return Math.round(tileSize * 0.38);
    if (digits === 4) return Math.round(tileSize * 0.32);
    return Math.round(tileSize * 0.28);
  }

  refreshTiles() {
    this.tiles.forEach((container, tile) => {
      this.renderTileVisual(container, tile.value);
      this.setTilePivot(container);
      const dest = this.getContainerPosition(tile.x, tile.y);
      container.position.set(dest.x, dest.y);
    });
  }

  refreshTileValue(value) {
    this.tiles.forEach((container, tile) => {
      if (tile.value !== value) return;
      this.renderTileVisual(container, tile.value);
      this.setTilePivot(container);
    });
  }

  tweenTo(target, to, duration, ease, onComplete) {
    const props = {};
    Object.keys(to).forEach((key) => {
      props[key] = { from: target[key], to: to[key] };
    });
    const tween = {
      target,
      props,
      duration: Math.max(16, duration),
      elapsed: 0,
      ease: ease || ((t) => t),
      onComplete,
    };
    this.tweens.add(tween);
    return tween;
  }

  removeTweens(target) {
    if (!this.tweens.size) return;
    // Optimize: iterating Set directly is fine, no need to create array unless deleting
    // We are deleting inside the loop in updateTweens, which is tricky, but here we scan.
    for (const tween of this.tweens) {
      if (tween.target === target) {
        this.tweens.delete(tween);
      }
    }
  }

  // --- CRITICAL FIX 3: Garbage Collection Optimization ---
  updateTweens() {
    if (!this.tweens.size) return;
    const deltaMS = this.app?.ticker?.deltaMS || 16.67;
    
    // Iterate the Set directly to avoid "Array.from" GC overhead
    this.tweens.forEach((tween) => {
      tween.elapsed += deltaMS;
      const t = Math.min(1, tween.elapsed / tween.duration);
      const eased = tween.ease(t);
      Object.keys(tween.props).forEach((key) => {
        const prop = tween.props[key];
        tween.target[key] = prop.from + (prop.to - prop.from) * eased;
      });
      if (t >= 1) {
        this.tweens.delete(tween);
        if (tween.onComplete) tween.onComplete();
      }
    });
  }

  destroy() {
    if (this.resizeObserver && this.hostEl) {
      this.resizeObserver.unobserve(this.hostEl);
      this.resizeObserver = null;
    }
    if (this.themeObserver) {
      this.themeObserver.disconnect();
      this.themeObserver = null;
    }
    this.tiles.forEach((container) => container.destroy({ children: true }));
    this.tiles.clear();
    this.tweens.clear();
    if (this.app) {
      this.app.ticker.remove(this.updateTweens, this);
      this.app.destroy({ removeView: true });
      this.app = null;
    }
  }
}
</file>

<file path="src/games/2048/components/Tile.js">
export class Tile {
  constructor(position, value) {
    this.x = position.x;
    this.y = position.y;
    this.value = value || 2;

    this.previousPosition = null;
    this.mergedFrom = null; // Tracks tiles that merged together
  }

  savePosition() {
    this.previousPosition = { x: this.x, y: this.y };
  }

  updatePosition(position) {
    this.x = position.x;
    this.y = position.y;
  }

  serialize() {
    return {
      position: {
        x: this.x,
        y: this.y,
      },
      value: this.value,
    };
  }
}
</file>

<file path="src/games/2048/index.js">
import { GameInterface } from '../../core/GameInterface.js';
import { GameManager } from './components/GameManager.js';
import { KeyboardInputManager } from './components/KeyboardInputManager.js';
import { PixiActuator } from './components/PixiActuator.js';
import { LocalStorageManager } from './components/LocalStorageManager.js';
import { PixiBoardRenderer } from './components/PixiBoardRenderer.js';

const ECONOMY_GAME_ID = "2048";
const GAME_OVER_QUOTES = [ /* Keep your existing quotes if you want, omitted for brevity */ ];

export class Photo2048 extends GameInterface {
    constructor() {
        super("2048");
        this.gameInstance = null;
        this.selectedTheme = 'classic';
        this.themeLoadToken = 0;
        this.customImages = {};
        this.customImageAvailability = {};
        this.currencyUnsubscribe = null;
        this.boardRenderer = null;
        this.actuator = null;
    }

async mount(container) {
        super.mount(container);
        this.container.innerHTML = this.getTemplate();
        this.setupUI();
        
        // 1. Initialize the Renderer
        this.initBoardRenderer();

        // 2. CRITICAL FIX: Wait for PixiJS to be ready before starting logic
        if (this.boardRenderer) {
            await this.boardRenderer.ready;
        }

        // Expose images to window so HTMLActuator can find them (legacy compat)
        window.CustomImages = this.customImages;
        window.customImageAvailability = this.customImageAvailability;
        this.bindCurrencyDisplay();
        
        this.applyTheme(this.selectedTheme);
        
        // 3. Now it is safe to start the game
        this.start();
    }

    applyTheme(theme) {
        this.selectedTheme = theme;
        this.themeLoadToken += 1;
        const token = this.themeLoadToken;
        this.customImageAvailability = {};
        window.customImageAvailability = this.customImageAvailability;

        document.body.classList.remove('classic', 'nature', 'darkmode'); 
        if (theme !== 'classic') {
            document.body.classList.add(theme);
        }
        
        // Only preload assets we ship
        const values = [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768];
        values.forEach(val => {
            this.customImages[val] = `assets/${theme}/${val}.jpg`;
            this.customImageAvailability[val] = false;
            const img = new Image();
            img.onload = () => {
                if (token !== this.themeLoadToken) return;
                this.customImageAvailability[val] = true;
                if (this.boardRenderer) {
                    this.boardRenderer.setTileTexture(val, img);
                }
                if (this.gameInstance && this.gameInstance.actuator) {
                     this.gameInstance.actuate();
                }
            };
            img.onerror = () => {
                if (token !== this.themeLoadToken) return;
                this.customImageAvailability[val] = false;
            };
            img.src = this.customImages[val];
        });
        window.CustomImages = this.customImages;
        if (this.boardRenderer) {
            this.boardRenderer.setThemeAssets(this.customImages, this.customImageAvailability);
        }
    }

    start() {
        if (!window.effectManager) {
            window.effectManager = new EffectManager(".game-container");
        } else {
            window.effectManager.resize();
        }

        const actuator = new PixiActuator(this.container, this.boardRenderer);
        this.actuator = actuator;

        // Clean up previous instance to remove event listeners
        if (this.gameInstance && this.gameInstance.destroy) {
            this.gameInstance.destroy();
        }

        this.gameInstance = new GameManager(4, KeyboardInputManager, actuator, LocalStorageManager, {
            onRestart: () => {
                this.showThemeSelector(); 
            },
            onEconomyRun: (hasState) => {
                if (!window.EconomyManager) return;
                if (hasState) {
                    window.EconomyManager.ensureRun(ECONOMY_GAME_ID);
                } else {
                    window.EconomyManager.startRun(ECONOMY_GAME_ID);
                }
            },
            onScore: (score) => {
                if (!window.EconomyManager) return;
                window.EconomyManager.awardFromScore(ECONOMY_GAME_ID, score);
            },
            onGameEnd: (score, grid, stats = {}) => {
                const evt = new CustomEvent("game:over", { detail: { score, grid, stats }, bubbles: true });
                this.container.dispatchEvent(evt);
            }
        });
    }

    resume() {
        if (window.effectManager && window.effectManager.resize) {
            window.effectManager.resize();
        }
        if (this.boardRenderer) {
            this.boardRenderer.resize();
        }
        if (this.gameInstance && this.gameInstance.actuate) {
            this.gameInstance.actuate();
        }
    }

    pause() {
        // No active loop to pause yet
    }

    destroy() {
        if (this.currencyUnsubscribe) {
            this.currencyUnsubscribe();
            this.currencyUnsubscribe = null;
        }
        if (this.boardRenderer) {
            this.boardRenderer.destroy();
            this.boardRenderer = null;
        }
        
        // Critical: cleanup input listeners
        if (this.gameInstance && this.gameInstance.destroy) {
            this.gameInstance.destroy();
        }
        this.gameInstance = null;
        
        this.actuator = null;
        super.destroy();
    }

    initBoardRenderer() {
        if (this.boardRenderer) return;
        const host = this.container?.querySelector(".game-container");
        if (!host) return;
        this.boardRenderer = new PixiBoardRenderer(host, {
            size: 4,
            imagePaths: this.customImages,
            imageAvailability: this.customImageAvailability
        });
    }

    showThemeSelector() {
        this.applyTheme(this.selectedTheme); 
        if (this.gameInstance) {
            this.gameInstance.reset();
        }
    }

    getTemplate() {
        return `
        <div class="container">
            <header class="glass-panel">
                <h1>2048</h1>
                <div class="scores">
                    <div class="score-container glass-pill" data-label="Score">
                        <span class="score-label">Score</span>
                        <span class="score-value">0</span>
                    </div>
                    <div class="best-container glass-pill" data-label="Best">
                        <span class="score-label">Best</span>
                        <span class="score-value">0</span>
                    </div>
                    <button id="settings-button" class="ui-button mini secondary settings-inline" aria-label="Settings">âš™</button>
                    
                    <div class="currency-container glass-pill" id="currency-balance" data-label="Coins">
                        <span class="score-label">Coins</span>
                        <span class="score-value">0</span>
                    </div>
                </div>
                <div class="header-buttons">
                    <button id="show-leaderboard" class="ui-button mini secondary header-left">ðŸ†</button>
                    <button id="undo-button" class="ui-button secondary undo-button" disabled>â†©ï¸ Undo</button>
                    <span class="header-spacer"></span>
                    <button class="restart-button ui-button gold">New Game</button>
                </div>
            </header>

            <div class="game-stage">
                <div class="game-container">
                    </div>

                <div class="game-message">
                    <p></p>
                    <div class="lower">
                        <a class="keep-playing-button ui-button small secondary">Keep playing</a>
                        <a class="retry-button ui-button small gold">Try again</a>
                    </div>
                </div>
            </div>
        </div>
        `;
    }

    setupUI() {
        const showButton = this.container.querySelector("#show-leaderboard");

        if (showButton) {
            showButton.addEventListener("click", (event) => {
                event.preventDefault();
                if (window.openLeaderboard) {
                    window.openLeaderboard();
                }
            });
        }

        const retryButton = this.container.querySelector(".retry-button");
        if (retryButton) {
            retryButton.addEventListener("click", (event) => {
                event.preventDefault();
                const stats = this.gameInstance?.getStats ? this.gameInstance.getStats() : {};
                const score = this.gameInstance?.score || 0;
                const payload = {
                    mode: "win",
                    score,
                    turns: Number(stats.turns) || 0,
                    undos: Number(stats.undos) || 0,
                    showEntryForm: true
                };
                const messageEl = this.container.querySelector(".game-message");
                if (messageEl) messageEl.classList.add("hidden");
                if (window.openLeaderboard) {
                    window.openLeaderboard(payload);
                }
            });
        }
    }

    bindCurrencyDisplay() {
        const display = this.container.querySelector("#currency-balance");
        if (!display || !window.EconomyManager) return;
        const update = (coins) => {
            const value = Number.isFinite(coins) ? coins : window.EconomyManager.getCoins();
            display.textContent = Number(value).toLocaleString();
        };
        update();
        if (window.AppBus && window.AppBus.on) {
            this.currencyUnsubscribe = window.AppBus.on("economy:changed", ({ coins }) => update(coins));
        }
    }
}
</file>

<file path="src/games/2048/style.css">
/* 2048 Game Specific Styles */

#view-2048.view {
  padding: 8px 0 72px;
  max-width: 100%;
  width: 100vw;
  align-items: center;
}

.game-container {
  /* Square board sizing logic */
  --board-span: clamp(340px, min(96vw, 70vh), 660px);
  --field-base: var(--board-span);
  --field-width: min(var(--field-base), 96vw);
  --grid-spacing: calc(var(--field-width) * 0.025);
  --grid-row-cells: 4;
  --tile-size: calc((var(--field-width) - (var(--grid-spacing) * (var(--grid-row-cells) + 1))) / var(--grid-row-cells));
  --tile-radius: calc(var(--tile-size) * 0.1);
  
  margin: 0 auto;
  width: var(--field-width);
  max-width: var(--field-width);
  aspect-ratio: 1 / 1;
  height: auto;
  
  /* Layout */
  position: relative;
  padding: 0;
  box-sizing: border-box;
  touch-action: none;
  overflow: hidden;
  
  /* Visuals - Inherits Glass variables, but specific to board */
  background: linear-gradient(160deg, rgba(255,255,255,0.9), rgba(255,255,255,0.82));
  border-radius: 16px;
  box-shadow: 0 18px 48px rgba(0,0,0,0.12), inset 0 1px 0 rgba(255,255,255,0.55);
}

.dark-mode .game-container {
  background: linear-gradient(160deg, rgba(24,24,28,0.92), rgba(16,16,18,0.88));
  box-shadow: 0 18px 48px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.06);
}

.container {
  --board-span: clamp(340px, min(96vw, 82vh), 660px);
  width: 100vw;
  max-width: 100vw;
  margin: 0 auto;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 16px;
  padding: 12px 0 24px;
  min-height: calc(100vh - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px));
}

.game-stage {
  /* ... keep existing vars ... */
  display: flex;
  
  align-items: flex-start;
  
  justify-content: center;
  flex: 1;
  width: 100%

  padding-top: 4vh; 
  padding-bottom: 0;
}

/* Header Grid Layout */
header {
  display: grid;
  grid-template-columns: 1fr auto; 
  gap: 12px;
  width: 100%;
  max-width: min(900px, 94vw, var(--board-span));
  padding: 12px 14px;
}

h1 {
  /* Using your text utility class would be better, but this is fine specific override */
  font-family: var(--ui-font-display);
  font-size: 34px;
  font-weight: 800;
  margin: 0;
  line-height: 1;
  color: var(--ui-text-primary);
  align-self: center;
}

.scores {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
  align-items: center;
}

.header-buttons {
  grid-column: 1 / -1;
  display: flex;
  align-items: center;
  gap: 10px;
  width: 100%;
  margin-top: 4px;
}

/* Button overrides specific to header layout */
.header-buttons .ui-button { width: auto; }
.header-buttons .ui-button:not(.mini) { min-width: 110px; }
.header-spacer { flex: 1; }

/* Score Containers - Now just layout helpers for .glass-pill */
.score-container, .best-container, .currency-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  min-width: 96px;
  min-height: 50px;
  padding: 6px 10px;
  line-height: 1.1;
  flex: 1;
  /* Critical for floating +4 animation */
  position: relative;
}

.score-label {
  font-size: 12px;
  font-weight: 700;
  color: var(--ui-text-secondary); /* Use var! */
  letter-spacing: 0.01em;
  line-height: 1.1;
}

.score-value {
  font-size: 18px;
  font-weight: 800;
  color: var(--ui-text-primary);
  line-height: 1.1;
}

.currency-container { display: none; }

/* --- GRID & TILES --- */
.game-container::before {
  content: "";
  position: absolute;
  inset: 0;
  background: radial-gradient(120% 120% at 20% 20%, rgba(0, 122, 255, 0.1), transparent 60%),
              radial-gradient(120% 120% at 80% 0%, rgba(255, 45, 85, 0.08), transparent 55%);
  pointer-events: none;
  z-index: 1;
}

.pixi-board {
  width: 100%;
  height: 100%;
  display: block;
  pointer-events: none;
}

/* Game Message Overlay */
.game-message {
  display: none;
  position: absolute;
  inset: 0;
  background: var(--material-thick);
  backdrop-filter: blur(25px) saturate(180%);
  -webkit-backdrop-filter: blur(25px) saturate(180%);
  z-index: 100;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  border-radius: 16px;
  padding: 24px;
  animation: fade-in 0.3s ease;
}

.game-message.game-won, .game-message.game-over { display: flex; }

.game-message p { 
  font-size: 38px; 
  font-weight: 800; 
  margin: 0 0 32px 0; 
  color: var(--ui-text-primary);
}

.game-message .ui-button {
  width: 100%;
  max-width: 260px;
  height: 50px;
}

@keyframes fade-in {
  0% { opacity: 0; transform: scale(0.95); }
  100% { opacity: 1; transform: scale(1); }
}

@media (max-width: 640px) {
  header {
    grid-template-columns: 1fr;
    align-items: flex-start;
    justify-items: center;
    text-align: center;
    max-width: 100%;
  }
  h1 { font-size: 32px; }
  .scores { width: 100%; justify-content: center; }
  .header-buttons { display: flex; gap: 8px; }
  .game-container {
    --board-span: min(96vw, 72vh);
  }
}

/* --- SCORE POPUPS (Global) --- */
.score-addition {
  position: absolute;
  top: 10px; /* adjusted to sit inside the box */
  right: 10px;
  color: var(--ui-accent); /* Gold color */
  font-size: 16px;
  font-weight: 800;
  opacity: 0;
  z-index: 50;
  pointer-events: none; /* Let clicks pass through */
  animation: float-up 600ms ease-out forwards;
}

@keyframes float-up {
  0% { 
    opacity: 1; 
    transform: translateY(0) scale(1); 
  }
  100% { 
    opacity: 0; 
    transform: translateY(-25px) scale(1.2); 
  }
}
</file>

<file path="style.css">
/* Global App Shell Overrides */
html, body {
  background: var(--ui-bg-gradient);
  color: var(--ui-text-primary);
  margin: 0;
  padding: 0;
  height: 100%;
  width: 100%;
  overflow: hidden;
  font-family: var(--ui-font);
  position: relative;
  overscroll-behavior: none;
}

*, *::before, *::after {
  box-sizing: border-box;
}

body::before, body::after {
  content: "";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background: radial-gradient(50% 50% at 20% 20%, var(--ui-aurora-1), transparent 50%),
              radial-gradient(45% 45% at 80% 0%, var(--ui-aurora-2), transparent 55%);
  filter: blur(50px);
  opacity: 0.8;
  z-index: 0;
  animation: drift var(--motion-slow) ease-in-out infinite alternate;
}

.app-shell {
  height: 100%;
  display: flex;
  flex-direction: column;
  position: relative;
  z-index: 1;
}

.app-main {
  flex: 1;
  overflow-y: auto;
  padding: 24px 0 120px;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
  height: 100%;
}

/* Floating Navbar (Elegant Glass Pill) - RESTORED */
.bottom-nav {
  display: none;
  position: fixed;
  bottom: 24px;
  bottom: calc(24px + env(safe-area-inset-bottom));
  left: 50%;
  transform: translateX(-50%);
  width: min(400px, 90vw);
  height: 64px;
  background: linear-gradient(145deg, rgba(255,255,255,0.8), rgba(255,255,255,0.68));
  backdrop-filter: blur(35px) saturate(180%);
  -webkit-backdrop-filter: blur(35px) saturate(180%);
  border: 1px solid var(--glass-border);
  box-shadow: 0 12px 32px rgba(0,0,0,0.14), inset 0 1px 0 rgba(255,255,255,0.6);
  border-radius: var(--radius-pill);
  display: flex;
  justify-content: space-around;
  align-items: center;
  padding: 0 16px;
  z-index: 1000;
  box-sizing: border-box;
  transition: transform var(--motion-medium) ease, box-shadow var(--motion-medium) ease, background var(--motion-medium) ease;
  animation: float var(--motion-slow) ease-in-out infinite alternate;
}

.dark-mode .bottom-nav {
  background:
    radial-gradient(120% 120% at 20% 20%, rgba(255,255,255,0.05), transparent 55%),
    radial-gradient(120% 120% at 80% 0%, rgba(0,0,0,0.35), transparent 60%),
    linear-gradient(145deg, rgba(24,24,28,0.9), rgba(16,16,20,0.92));
  box-shadow: 0 16px 36px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.04);
  border-color: rgba(255,255,255,0.08);
}

.nav-button {
  background: transparent;
  color: var(--ui-text-secondary);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  font-size: 10px;
  font-weight: 600;
  padding: 4px;
  transition: all 0.2s ease;
  opacity: 0.5;
  width: 66px;
  cursor: pointer;
  border-radius: var(--radius-pill);
}

.dark-mode .nav-button {
  color: rgba(224,228,236,0.78);
}

.nav-button.active {
  color: var(--ui-accent);
  opacity: 1;
  transform: translateY(-2px);
  text-shadow: 0 0 8px rgba(0, 122, 255, 0.35);
  background: rgba(0, 122, 255, 0.12);
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.4), 0 8px 16px rgba(0,0,0,0.12);
}

.nav-button span {
  transition: color 180ms ease;
}

.nav-button.active span {
  color: var(--ui-accent);
}

.nav-button svg {
  width: 22px;
  height: 22px;
}

/* View Overrides */
.view {
  width: 100%;
  display: flex;
  flex-direction: column;
  padding: 16px;
  box-sizing: border-box;
  max-width: 1200px;
  gap: 12px;
  align-items: center;
  margin: 0 auto;
}

.view-header {
  padding-bottom: 16px;
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
  gap: 12px;
}

.view-header h2 {
  font-size: 34px;
  font-weight: 800;
  margin: 0;
  color: var(--ui-text-primary);
  line-height: 1;
}

.view-subtitle {
  font-size: 16px;
  color: var(--ui-text-secondary);
  margin-top: 4px;
}

/* City View Specifics */
#view-city {
    height: 100%;
    display: flex;
    flex-direction: column;
    padding: 0; /* City takes full space */
}

#view-city .view-header {
    padding: 20px;
    background: var(--material-regular);
    backdrop-filter: blur(10px);
    z-index: 100;
}

#city-root {
    flex: 1;
    width: 100%;
    position: relative;
    overflow: hidden;
    background: var(--ui-bg-base);
}

.city-tools {
    display: flex;
    gap: 6px;
}

.city-palette {
    height: 110px;
    display: flex;
    gap: 10px;
    overflow-x: auto;
    padding: 10px 20px;
    background: var(--material-regular);
    backdrop-filter: blur(15px);
    border-top: 1px solid var(--glass-border);
    margin-bottom: calc(88px + env(safe-area-inset-bottom));
    align-items: center;
    z-index: 100;
}

.city-item {
    flex: 0 0 80px;
    height: 80px;
    background: var(--ui-bg-base);
    border: 1px solid var(--ui-separator);
    border-radius: 14px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 6px;
    position: relative;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: var(--shadow-sm);
}

.city-item.active {
    border-color: var(--ui-accent);
    background: var(--ui-bg-base);
    transform: scale(1.05);
    box-shadow: 0 8px 20px rgba(0,0,0,0.1);
    z-index: 2;
}

.city-item.locked {
    opacity: 0.4;
    filter: grayscale(1);
}

.city-item-preview {
    width: 32px;
    height: 32px;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    margin-bottom: 4px;
}

.city-item-name {
    font-size: 10px;
    font-weight: 600;
    max-width: 70px;
    text-align: center;
}

.city-item-count {
    position: absolute;
    top: -6px;
    right: -6px;
    font-size: 10px;
    background: var(--ui-text-primary);
    color: var(--ui-bg-base);
    padding: 2px 6px;
    border-radius: 10px;
    font-weight: 700;
    border: 2px solid var(--ui-bg-base);
}

.city-hint {
    position: absolute;
    bottom: 220px;
    left: 50%;
    transform: translateX(-50%);
    padding: 8px 16px;
    font-size: 13px;
    font-weight: 600;
    pointer-events: none;
    z-index: 10;
    color: var(--ui-text-primary);
}

/* Game & Shop Lists */
.game-list, .shop-list {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 16px;
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
}

.game-card, .shop-item {
  background: var(--material-regular);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border-radius: var(--radius-lg);
  padding: 20px;
  box-shadow: var(--shadow-md);
  border: 1px solid var(--glass-border);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.game-card h3, .shop-title {
  margin: 0;
  font-size: 20px;
  font-weight: 600;
}

/* Theme Toggle Position */
.settings-button {
  position: fixed;
  right: 20px;
  bottom: calc(100px + env(safe-area-inset-bottom));
  width: 46px;
  height: 46px;
  border-radius: 50%;
  border: 1px solid var(--glass-border);
  background: var(--material-regular);
  color: var(--ui-text-primary);
  box-shadow: var(--shadow-md);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  cursor: pointer;
  z-index: 2000;
  transition: transform var(--motion-fast) ease, box-shadow var(--motion-medium) ease, background var(--motion-medium) ease;
}

.settings-button:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}

.settings-button:active {
  transform: scale(0.96);
}

.dark-mode .settings-button {
  background: rgba(30,30,34,0.9);
  color: rgba(230,232,238,0.9);
  box-shadow: 0 14px 28px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.05);
}

.settings-panel {
  max-width: 420px;
  width: 92vw;
}

.settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 12px;
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-md);
  background: var(--material-thin);
  box-shadow: var(--shadow-sm);
}

@media (max-width: 768px) {
  .settings-button {
    bottom: calc(88px + env(safe-area-inset-bottom));
    right: 16px;
  }
}

/* Utility */
.hidden {
  display: none !important;
}

.leaderboard-entry {
  display: grid;
  gap: 8px;
  padding: 12px;
  border-radius: var(--radius-md);
  border: 1px solid var(--glass-border);
  background: var(--material-thin);
}

.leaderboard-status {
  padding: 10px 12px;
  border-radius: var(--radius-md);
  border: 1px solid var(--glass-border);
  background: var(--material-ultra-thin);
  color: var(--ui-text-primary);
  box-shadow: var(--shadow-sm);
  font-weight: 600;
}

.leaderboard-status.ok { color: var(--system-green); }
.leaderboard-status.error { color: var(--system-red); }

.overlay-actions {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
}

#high-score-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
  padding: 0;
}

#high-score-list .ui-list-item {
  list-style: none;
}

.leader-card {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 14px;
  padding: 12px 10px;
  border-radius: 16px;
  background: rgba(255,255,255,0.86);
  border: 1px solid rgba(0,0,0,0.04);
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.5), 0 8px 18px rgba(0,0,0,0.12);
  position: relative;
}

 .dark-mode .leader-card {
  background: rgba(28,28,32,0.8);
  border: 1px solid rgba(255,255,255,0.05);
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.05), 0 10px 20px rgba(0,0,0,0.28);
}

.leader-card .lb-left {
  display: flex;
  align-items: center;
  gap: 10px;
  min-width: 0;
  flex: 1 1 50%;
}

.leader-card .lb-rank {
  width: 36px;
  height: 36px;
  min-width: 36px;
  border-radius: 12px;
  background: rgba(0,0,0,0.06);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-weight: 800;
  color: #2b2b2b;
}

.dark-mode .leader-card .lb-rank { background: rgba(255,255,255,0.08); color: rgba(240,242,247,0.9); }

.leader-card .lb-rank.gold { color: #f7c948; background: rgba(247,201,72,0.15); }
.leader-card .lb-rank.silver { color: #556473; background: rgba(200,210,220,0.12); }
.leader-card .lb-rank.bronze { color: #b26f3c; background: rgba(215,149,91,0.12); }

.leader-card .lb-player {
  display: flex;
  flex-direction: column;
  gap: 2px;
  flex: 1;
  min-width: 0;
}

.leader-card .lb-name {
  font-weight: 700;
  white-space: normal;
  overflow: hidden;
  text-overflow: ellipsis;
}

.leader-card .lb-date {
  opacity: 0.75;
}

.leader-card .lb-right {
  display: flex;
  align-items: center;
  gap: 12px;
  flex: 0 0 auto;
}

.leader-card .lb-stat {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 2px;
  min-width: 52px;
}

.leader-card .lb-stat-label {
  font-size: 11px;
  opacity: 0.75;
}

.leader-card .lb-stat-value {
  font-weight: 700;
}

.leader-card .lb-score {
  font-weight: 800;
  font-size: 18px;
  min-width: 76px;
  text-align: right;
}

.leader-card .lb-stat-stack {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

#leaderboard {
  --gold-glow: rgba(255, 214, 120, 0.22);
}

#leaderboard .glass-panel {
  background: radial-gradient(80% 60% at 50% 0%, rgba(255, 214, 120, 0.08), transparent 70%), var(--material-regular);
  box-shadow: 0 20px 50px rgba(0,0,0,0.35), 0 0 0 1px rgba(255,255,255,0.05), 0 12px 32px var(--gold-glow);
}

#leaderboard .ui-list {
  background: rgba(255,255,255,0.78);
  border: 1px solid rgba(0,0,0,0.04);
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.4), 0 10px 24px rgba(0,0,0,0.18);
  padding: 12px;
  border-radius: 20px;
}

.dark-mode #leaderboard .ui-list {
  background: rgba(20,20,22,0.82);
  border: 1px solid rgba(255,255,255,0.05);
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.04), 0 12px 26px rgba(0,0,0,0.35);
}

#leaderboard-entry {
  border: 1px solid rgba(255,255,255,0.06);
  background: rgba(255,255,255,0.02);
}

#leaderboard-pending {
  color: #f7c948;
  font-weight: 700;
}

#leaderboard .leaderboard-form input[type="text"] {
  background: rgba(255,255,255,0.1);
  color: var(--ui-text-primary);
  border: 1px solid rgba(255,255,255,0.08);
}

.dark-mode #leaderboard .leaderboard-form input[type="text"] {
  background: rgba(255,255,255,0.08);
  color: rgba(235,238,244,0.95);
}

/* Leaderboard input theming */
#leaderboard .leaderboard-form input[type="text"] {
  background: var(--material-thin);
  color: var(--ui-text-primary);
  border: 1px solid var(--glass-border);
  box-shadow: inset 0 1px 0 var(--glass-highlight);
}

.dark-mode #leaderboard .leaderboard-form input[type="text"] {
  background: rgba(30,30,34,0.9);
  color: rgba(235,238,244,0.92);
  border-color: rgba(255,255,255,0.06);
}

#leaderboard .leaderboard-form input::placeholder {
  color: rgba(255,255,255,0.55);
}

@keyframes float {
  0% { transform: translate(-50%, 0); }
  100% { transform: translate(-50%, -4px); }
}

@keyframes drift {
  0% { transform: translate3d(0, 0, 0) scale(1); }
  100% { transform: translate3d(-10px, 8px, 0) scale(1.03); }
}

@media (max-width: 768px) {
  .bottom-nav {
    width: 94vw;
    height: 60px;
  }
  .view-header h2 {
    font-size: 28px;
  }
  .view-header {
    align-items: flex-start;
  }
  .app-main {
    padding: 12px 0 100px;
  }
  .view {
    padding: 12px 10px;
  }
}
</file>

<file path="styleguide.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcade City // Theme Comparison</title>
    
    <link rel="stylesheet" href="./ui/theme.css">
    <link rel="stylesheet" href="./ui/components.css">
    
    <style>
        /* --- LAYOUT & UTILITIES --- */
        body { margin: 0; padding: 0; font-family: sans-serif; height: 100vh; display: flex; overflow: hidden; }
        
        /* The Split Container */
        .split-view {
            display: flex;
            width: 100%;
            height: 100%;
        }

        /* Common Styles for both sides */
        .theme-pane {
            flex: 1;
            padding: 40px;
            overflow-y: auto;
            position: relative;
            /* Apply the theme variables to the container background */
            background: var(--ui-bg-base);
            background-image: var(--ui-bg-gradient);
            color: var(--ui-text-primary);
        }

        /* --- THE MAGIC TRICK --- 
           We manually apply your Dark Mode variables to this specific class
           so it renders 'Dark' even though the <body> is technically Light.
        */
        .theme-pane.dark-forced {
            --ui-bg-base: #000000;
            --ui-bg-secondary: #1C1C1E;
            --ui-text-primary: #FFFFFF;
            --ui-text-secondary: #8E8E93;
            --ui-text-tertiary: #48484A;
            --ui-separator: #38383A;
            --ui-bg-gradient: linear-gradient(135deg, #000000 0%, #1C1C1E 100%);
            
            /* Materials */
            --material-ultra-thin: rgba(30, 30, 30, 0.48);
            --material-thin: rgba(30, 30, 30, 0.70);
            --material-regular: rgba(30, 30, 30, 0.82);
            --material-thick: rgba(28, 28, 30, 0.94);
            
            --glass-border: rgba(255, 255, 255, 0.15);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
            
            /* Apply the override to the button text color in dark mode context */
            --ui-button-text: #FFF; 
        }

        /* Section Styling */
        section { margin-bottom: 60px; border-bottom: 1px solid var(--ui-separator); padding-bottom: 30px; }
        h2 { 
            font-family: var(--ui-font-display); 
            text-transform: uppercase; 
            letter-spacing: 1px; 
            opacity: 0.6; 
            font-size: 14px; 
            margin-bottom: 24px;
        }

        /* Component Grid */
        .grid { display: grid; gap: 24px; align-items: start; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); }
        
        .label {
            display: block; margin-top: 12px; font-size: 11px; font-family: monospace; opacity: 0.5;
        }

        /* Header for the Pane */
        .pane-header {
            font-size: 32px; font-weight: 800; margin-bottom: 8px; font-family: var(--ui-font-display);
        }
    </style>
</head>
<body>

    <div class="split-view">
        
        <div class="theme-pane">
            <div class="pane-header">Light Mode</div>
            <p class="text-body-sm" style="margin-bottom: 40px;">Standard daylight presentation.</p>

            <div id="light-content"></div>
        </div>

        <div class="theme-pane dark-forced">
            <div class="pane-header">Dark Mode</div>
            <p class="text-body-sm" style="margin-bottom: 40px;">Aurora night presentation.</p>

            <div id="dark-content"></div>
        </div>

    </div>

    <template id="component-template">
        
        <section>
            <h2>Buttons</h2>
            <div class="grid">
                <div>
                    <button class="ui-button gold">Start</button>
                    <span class="label">.gold</span>
                </div>
                <div>
                    <button class="ui-button secondary">Settings</button>
                    <span class="label">.secondary</span>
                </div>
                <div>
                    <button class="ui-button mini secondary">ðŸ””</button>
                    <span class="label">.mini</span>
                </div>
            </div>
        </section>

        <section>
            <h2>Glass Panels</h2>
            <div style="display: flex; flex-direction: column; gap: 20px;">
                
                <div class="glass-panel" style="padding: 24px;">
                    <h3 class="ui-title" style="font-size: 20px; margin-bottom: 8px;">Main Menu</h3>
                    <p class="text-body">The glass panel adapts to the background luminosity automatically.</p>
                </div>

                <div class="ui-list">
                    <div class="ui-list-item">
                        <span class="text-body">Sound Effects</span>
                        <label class="ui-toggle">
                            <input type="checkbox" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="ui-list-item">
                        <span class="text-body">Notifications</span>
                        <label class="ui-toggle">
                            <input type="checkbox">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>

            </div>
        </section>

        <section>
            <h2>Typography</h2>
            <div style="display: flex; flex-direction: column; gap: 16px;">
                <h1 class="text-hero">Hero Title</h1>
                <p class="text-body">This is standard body text. It should have high contrast in Light Mode and slightly softer white in Dark Mode.</p>
                <span class="text-body-sm">Secondary / Caption text</span>
            </div>
        </section>

        <section>
            <h2>Inputs</h2>
            <div class="grid">
                <input type="text" placeholder="Username...">
                <div class="glass-pill" style="padding: 8px 16px; display: inline-flex;">
                    <span>ðŸª™ 1,040</span>
                </div>
            </div>
        </section>

    </template>

    <script>
        // This script takes the template above and clones it into both left and right sides
        // So you only have to write the HTML once.
        const template = document.getElementById('component-template');
        const lightContainer = document.getElementById('light-content');
        const darkContainer = document.getElementById('dark-content');

        lightContainer.appendChild(template.content.cloneNode(true));
        darkContainer.appendChild(template.content.cloneNode(true));
    </script>
</body>
</html>
</file>

<file path="sw.js">
const CACHE_NAME = 'photo-2048-v2';
const ASSETS_TO_CACHE = [
  './',
  './index.html',
  './style.css',
  './manifest.json',
  './ui/theme.css',
  './ui/components.css',
  './core.js',
  './effects.js',
  './app.js',
  './src/core/GameInterface.js',
  './src/games/2048/index.js',
  './src/games/2048/style.css',
  './src/games/2048/components/GameManager.js',
  './src/games/2048/components/Grid.js',
  './src/games/2048/components/HTMLActuator.js',
  './src/games/2048/components/KeyboardInputManager.js',
  './src/games/2048/components/LocalStorageManager.js',
  './src/games/2048/components/Tile.js',
  './city/src/MinigameBase.js',
  './city/src/CityScene.js',
  './vendor/pixi.min.js'
];

// Add image assets dynamically if needed, or list critical ones
const THEMES = ['classic', 'nature', 'darkmode'];
const TILE_VALUES = [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192];

THEMES.forEach(theme => {
    TILE_VALUES.forEach(val => {
        ASSETS_TO_CACHE.push(`./assets/${theme}/${val}.jpg`);
    });
});

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(ASSETS_TO_CACHE))
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => response || fetch(event.request))
  );
});

self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});
</file>

<file path="TDD.md">
# Technical Design Document (TDD) - v2.1 (ESM)

## 1. Architecture Overview
Arcade City uses a **Hub & Spoke** model implemented with modern JavaScript **ES Modules**.

### 1.1 The Console (App Shell)
`app.js` acts as the operating system. It handles:
*   **Routing:** Switching between `city`, `2048`, `games`, and `shop` views.
*   **Lifecycle:** Orchestrating `mount`, `start`, `pause`, and `resume` calls on active game modules.
*   **Global State:** Managing `EconomyManager` (coins/inventory) via `core.js`.
*   **Leaderboards:** Opens the leaderboard sheet on `game:over` events and pipes data through `LeaderboardManager` (local-first, Firebase-enabled).

### 1.2 The Cartridges (Game Modules)
Each game is a standalone module in `src/games/`.
*   **Interface:** All games must inherit from `src/core/GameInterface.js`.
*   **Isolation:** Games manage their own DOM injection and internal logic (e.g., `GameManager`, `Grid`).
*   **Communication:** Games talk to the Shell via standard JS events or provided callbacks.

## 2. Component API Reference

### GameInterface
Every game module must implement:
*   `mount(container)`: One-time setup of HTML/Canvas.
*   `start()`: Activation of game logic/loops.
*   `pause()`: Hibernation (save battery).
*   `resume()`: Re-activation from pause.
*   `destroy()`: Total cleanup.

### EconomyManager
Accessible via `window.EconomyManager`:
*   `awardFromScore(gameId, score)`: Converts game points to coins.
*   `purchaseItem(item)`: Handles transactions.
*   `getInventory()`: Returns owned items.

### LeaderboardManager
Located at `src/core/LeaderboardManager.js`, used by `app.js`:
*   `submitScore(name, score, stats)`: Saves locally and to Firebase (when enabled) with `score`, `turns`, `undos`.
*   `fetchScores(limit)`: Returns `{ local, remote }` score arrays (remote only when Firebase is configured).
*   `isHighScore(score)`: Determines if an entry should prompt the save form.
*   Storage keys: defaults to `photo2048HighScores` for the 2048 cartridge.

## 3. Rendering
*   **UI:** Native HTML/CSS overlays (fast, accessible).
*   **City:** PixiJS v8 (Canvas) for isometric performance.
*   **Minigames:** 2048 board uses PixiJS v8 with HTML overlay UI; Match-3 planned for PixiJS.
*   **Liquid Glass:** `ui/theme.css` carries aurora gradients + `--motion-*` tokens; `ui/components.css` provides glass cards/pills and focus-visible handling. 2048 uses `src/games/2048/style.css` for responsive board sizing and glass overlay animations.

## 3.5 UI Component Guidelines
- Prefer the shared button variants: ui-button (primary), ui-button secondary (glass), ui-button gold (gold CTA), and ui-button mini secondary (44px circular icon chips).
- Reuse the 2048 score chip markup (.score-container with .score-label and .score-value) to maintain sizing and alignment across themes.
- For leaderboards, use the .leader-card structure with .lb-rank, .lb-player (name + date), .lb-score, and .lb-stat-stack for stats (undos/turns). Add stats by extending the stack instead of altering the layout.

### 3.6 Animation & Audio
* **Complex Motion:** **GSAP (GreenSock)** is required for Match-3 sequencing (swap/drop cascades) and complex UI state transitions.
* **Audio:** **Howler.js** manages audio sprites (SFX) and background loops to ensure low-latency playback on iOS.
* **Haptics:** `navigator.vibrate()` calls are wrapped in `GameInterface` for tactile feedback on valid moves/errors.

## 4. Firebase / Leaderboards
*   Config: provide `window.firebaseConfig` or call `window.FirebaseManager.configure(config)` to enable Firestore-backed leaderboards.
*   Transport: `FirebaseManager` loads Firebase from the CDN to avoid bundling dependencies.
*   Fallback: If Firebase is absent/offline, leaderboard reads/writes remain local only.
*   Stored fields: `name`, `score`, `turns`, `undos`, `timestamp`.
*   Index: Firestore requires a composite index on `leaderboards` for `gameId (ASC)` + `score (DESC)` to satisfy the cloud query; the console will link to create it if missing.

## 5. UI State (Current)
*   Active surface: 2048 only. Bottom navigation is hidden; coins UI is suppressed until the economy/city/shop flows are production-ready.
*   Settings are accessed via the header cog; theme toggle lives in the settings overlay.
*   Input: Pointer-based swipe handling on a full-height `.game-stage` wrapper with `touch-action: none` keeps the entire play area (including the space beneath the board) interactive without blocking header buttons.
</file>

<file path="ui/components.css">
/* Reset & Base */
button {
  all: unset;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
}

/* Glass Material Utilities */
.glass-panel {
  background: var(--material-regular);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border: 1px solid var(--glass-border);
  box-shadow: 0 16px 40px rgba(0,0,0,0.1), inset 0 1px 0 var(--glass-highlight);
  border-radius: var(--radius-lg);
  color: var(--ui-text-primary);
}

.glass-pill {
  background: var(--material-thin);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border: 1px solid var(--glass-border);
  border-radius: var(--radius-pill);
  box-shadow: var(--shadow-sm);
}

/* Buttons (Apple Style - Refined) */
.ui-button, button {
  font-family: var(--ui-font);
  font-weight: 600;
  font-size: 15px;
  height: 44px; /* Apple HIG standard tap target */
  padding: 0 24px;
  border-radius: var(--radius-pill);
  background: var(--ui-accent-gradient);
  color: #FFFFFF;
  border: none;
  box-shadow: 0 8px 22px var(--gold-shadow, rgba(249, 178, 51, 0.24));
  transition: transform var(--motion-fast) ease, opacity var(--motion-fast) ease, box-shadow var(--motion-medium) ease;
  cursor: pointer;
}

.ui-button:hover, button:hover {
  box-shadow: 0 12px 28px var(--gold-shadow, rgba(249, 178, 51, 0.32));
  transform: translateY(-1px);
}

.ui-button:active, button:active {
  transform: scale(0.97);
  opacity: 0.9;
  box-shadow: 0 6px 16px var(--gold-shadow, rgba(249, 178, 51, 0.24));
}

.ui-button.primary { /* default accent */
  background: var(--ui-accent-gradient);
}

.ui-button.gold {
  background: linear-gradient(145deg, #ffcc5c, #f9b233);
  color: #1d1b16;
  box-shadow: 0 10px 26px rgba(0,0,0,0.35), 0 0 18px rgba(255,204,92,0.35);
}

.ui-button.gold:hover {
  box-shadow: 0 12px 30px rgba(0,0,0,0.38), 0 0 20px rgba(255,204,92,0.4);
}

.ui-button.gold:active {
  transform: scale(0.98);
  box-shadow: 0 8px 20px rgba(0,0,0,0.3), inset 0 2px 4px rgba(255,255,255,0.2);
}

.ui-button.secondary, button.secondary {
  background: var(--material-thin);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  color: var(--ui-text-primary);
  border: 1px solid var(--glass-border);
  box-shadow: var(--shadow-sm);
}

.ui-button.small, button.small {
  height: 36px;
  padding: 0 16px;
  font-size: 14px;
}

.ui-button.icon-only, button.icon-only {
  width: 44px;
  padding: 0;
  border-radius: 50%;
}

.ui-button.mini {
  width: 44px;
  height: 44px;
  min-width: 44px;
  padding: 0;
  border-radius: 50%;
  aspect-ratio: 1 / 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.4), 0 6px 16px rgba(0,0,0,0.18);
}

.ui-button.mini.secondary {
  background: var(--material-thin);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  color: var(--ui-text-primary);
  border: 1px solid var(--glass-border);
  box-shadow: var(--shadow-sm);
}

.ui-button.mini.secondary:hover { background: rgba(255,255,255,0.18); }
.ui-button.mini.secondary:active { transform: scale(0.97); }

.dark-mode .ui-button.mini.secondary {
  background: var(--material-thin);
  border-color: rgba(255,255,255,0.18);
  color: rgba(235,238,244,0.9);
}

button:focus-visible, .ui-button:focus-visible {
  outline: 2px solid var(--ui-accent);
  outline-offset: 2px;
}

/* Typography */
.ui-title {
  font-family: var(--ui-font-display);
  font-weight: 700;
  letter-spacing: 0.01em;
  color: var(--ui-text-primary);
}

.ui-caption {
  font-family: var(--ui-font);
  font-size: 12px;
  color: var(--ui-text-secondary);
  font-weight: 500;
}

/* Lists & Tables */
.ui-list {
  display: flex;
  flex-direction: column;
  background: var(--material-regular);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border-radius: var(--radius-lg);
  padding: 0;
  margin: 0;
  overflow: hidden;
}

.ui-list-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px;
  border-bottom: 1px solid var(--ui-separator);
}

.ui-list-item:last-child {
  border-bottom: none;
}

/* Inputs */
input[type="text"], input[type="number"] {
  height: 36px;
  background: var(--system-gray6);
  border: none;
  border-radius: 8px;
  padding: 0 12px;
  font-size: 17px;
  color: var(--ui-text-primary);
  width: 100%;
}

input:focus {
  outline: 2px solid var(--ui-accent);
  background: var(--ui-bg-base);
}

/* Toggles (Apple Switch Style) */
.ui-toggle {
  position: relative;
  display: inline-block;
  width: 51px;
  height: 31px;
}

.ui-toggle input { 
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0; left: 0; right: 0; bottom: 0;
  background-color: var(--system-gray5);
  transition: .4s;
  border-radius: 31px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 27px;
  width: 27px;
  left: 2px;
  bottom: 2px;
  background-color: white;
  transition: .4s;
  border-radius: 50%;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

input:checked + .slider {
  background-color: var(--ui-accent);
}

input:checked + .slider:before {
  transform: translateX(20px);
}

/* Overlays / Modals */
.overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.4);
  backdrop-filter: blur(5px);
  -webkit-backdrop-filter: blur(5px);
  z-index: 2000;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 1;
  transition: opacity 0.3s ease;
}

.overlay.hidden {
  opacity: 0;
  pointer-events: none;
  display: none; /* Fallback */
}

.overlay-content {
  width: 90%;
  max-width: 400px;
  max-height: 80vh;
  overflow-y: auto;
  padding: 24px;
  display: flex;
  flex-direction: column;
  gap: 16px;
  animation: scale-up 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.overlay-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.leaderboard-form {
  display: flex;
  gap: 8px;
}

@keyframes scale-up {
  0% { transform: scale(0.9); opacity: 0; }
  100% { transform: scale(1); opacity: 1; }
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* Add to ui/components.css */
.text-hero { font-family: var(--ui-font-display); font-weight: 800; font-size: 34px; letter-spacing: -0.01em; }
.text-body { font-size: 17px; line-height: 1.4; color: var(--ui-text-primary); }
.text-body-sm { font-size: 15px; line-height: 1.4; color: var(--ui-text-secondary); }
</file>

<file path="ui/theme.css">
:root {
  /* Fonts */
  --ui-font: -apple-system, "SF Pro Text", "SF Pro Icons", "Helvetica Neue", Helvetica, Arial, sans-serif;
  --ui-font-display: -apple-system, "SF Pro Display", "SF Pro Icons", "Helvetica Neue", Helvetica, Arial, sans-serif;

  /* Apple HIG Colors - Light Mode Default */
  --system-blue: #007AFF;
  --gold-base: #f9b233;
  --gold-bright: #ffcc5c;
  --gold-shadow: rgba(249, 178, 51, 0.35);
  --system-green: #34C759;
  --system-indigo: #5856D6;
  --system-orange: #FF9500;
  --system-pink: #FF2D55;
  --system-purple: #AF52DE;
  --system-red: #FF3B30;
  --system-teal: #5AC8FA;
  --system-yellow: #FFCC00;
  --system-gray: #8E8E93;
  --system-gray2: #AEAEB2;
  --system-gray3: #C7C7CC;
  --system-gray4: #D1D1D6;
  --system-gray5: #E5E5EA;
  --system-gray6: #F2F2F7;

  /* Semantic Colors */
  --ui-bg-base: #FFFFFF;
  --ui-bg-secondary: #F2F2F7;
  --ui-text-primary: #000000;
  --ui-text-secondary: #8E8E93; /* Label Color */
  --ui-text-tertiary: #C7C7CC;
  --ui-separator: #C6C6C8;
  
  /* Refined Accent - Classic Apple Blue (Solid) */
  --ui-accent: var(--gold-base);
  --ui-accent-gradient: linear-gradient(145deg, var(--gold-bright), var(--gold-base));
  --ui-accent-highlight: rgba(249, 178, 51, 0.18);
  
  /* Materials (Liquid Glass) - Softer */
  --material-ultra-thin: rgba(255, 255, 255, 0.48);
  --material-thin: rgba(255, 255, 255, 0.70);
  --material-regular: rgba(255, 255, 255, 0.82);
  --material-thick: rgba(255, 255, 255, 0.94);
  
  --glass-border: rgba(255, 255, 255, 0.2);
  --glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
  --glass-highlight: rgba(255, 255, 255, 0.45);

  /* Background Gradient & Aurora accents */
  --ui-bg-gradient: radial-gradient(120% 120% at 20% 20%, rgba(0, 122, 255, 0.16) 0%, rgba(0, 122, 255, 0) 50%),
                    radial-gradient(120% 120% at 80% 0%, rgba(255, 45, 85, 0.12) 0%, rgba(255, 45, 85, 0) 45%),
                    linear-gradient(135deg, #f6f7fb 0%, #d9e1f2 50%, #f5f7fa 100%);
  --ui-aurora-1: rgba(0, 122, 255, 0.16);
  --ui-aurora-2: rgba(255, 45, 85, 0.12);

  /* Metrics */
  --radius-xs: 8px;
  --radius-sm: 12px;
  --radius-md: 18px;
  --radius-lg: 24px;
  --radius-xl: 32px;
  --radius-pill: 9999px;
  
  --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.04);
  --shadow-md: 0 8px 24px rgba(0, 0, 0, 0.08);
  --shadow-lg: 0 16px 48px rgba(0, 0, 0, 0.12);

  /* Motion */
  --motion-fast: 150ms;
  --motion-medium: 260ms;
  --motion-slow: 480ms;
}

/* Dark Mode Overrides */
body.dark-mode {
    --ui-bg-base: #000000;
    --ui-bg-secondary: #1C1C1E;
    --ui-text-primary: #FFFFFF;
    --ui-text-secondary: #8E8E93;
    --ui-text-tertiary: #48484A;
    --ui-separator: #38383A;

    --ui-bg-gradient: linear-gradient(135deg, #000000 0%, #1C1C1E 100%);
    --ui-aurora-1: rgba(90, 200, 250, 0.14);
    --ui-aurora-2: rgba(175, 82, 222, 0.12);

    /* Apple Dark Mode Translucency Bases */
    --material-ultra-thin: rgba(30, 30, 30, 0.48);
    --material-thin: rgba(30, 30, 30, 0.70);
    --material-regular: rgba(30, 30, 30, 0.82);
    --material-thick: rgba(28, 28, 30, 0.94); /* System Gray 6 equivalent */
    
    --glass-border: rgba(255, 255, 255, 0.15);
    --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
}
</file>

<file path="verification/verify_animations.py">
import json
from playwright.sync_api import sync_playwright
import time
import os

def run_verification():
    with sync_playwright() as p:
        browser = p.chromium.launch()
        page = browser.new_page()
        
        file_url = f"file://{os.path.abspath('index.html')}"
        
        # Load the game first to establish origin
        page.goto(file_url)
        
        # Prepare game state
        game_state = {
            "grid": {
                "size": 4,
                "cells": [
                    [
                        {"position": {"x": 0, "y": 0}, "value": 1024},
                        {"position": {"x": 0, "y": 1}, "value": 1024},
                        None, None
                    ],
                    [
                        {"position": {"x": 1, "y": 0}, "value": 262144},
                        {"position": {"x": 1, "y": 1}, "value": 262144},
                        None, None
                    ],
                    [None, None, None, None],
                    [None, None, None, None]
                ]
            },
            "score": 0,
            "over": False,
            "won": False,
            "keepPlaying": False
        }
        
        # Set localStorage
        # Note: We need to make sure the game logic doesn't immediately overwrite it on the *next* load before reading.
        # The game reads on setup().
        page.evaluate(f"window.localStorage.setItem('gameState', '{json.dumps(game_state)}');")
        
        # Reload to pick up the new state
        page.reload()
        
        # Wait for tiles to appear
        try:
            page.wait_for_selector(".tile-1024", timeout=2000)
            page.wait_for_selector(".tile-262144", timeout=2000)
        except Exception as e:
            print("Failed to find initial tiles. Maybe localStorage didn't persist or logic is flawed.")
            page.screenshot(path="verification/failed_load.png")
            raise e
        
        print("Initial state loaded.")
        page.screenshot(path="verification/before_merge.png")
        
        # Trigger merge: Press Up (ArrowUp)
        page.keyboard.press("ArrowUp")
        
        time.sleep(0.1) # Wait for JS to process
        
        # Check if merged classes exist
        tile_2048 = page.query_selector(".tile-2048.tile-merged-2048")
        tile_524288 = page.query_selector(".tile-524288.tile-merged-524288")
        
        if tile_2048:
            print("SUCCESS: Found merged 2048 tile with animation class.")
        else:
            print("FAILURE: Did not find merged 2048 tile.")
            # Dump html to see what's there
            with open("verification/dump.html", "w") as f:
                f.write(page.content())
            
        if tile_524288:
            print("SUCCESS: Found merged 524288 tile with animation class.")
        else:
            print("FAILURE: Did not find merged 524288 tile.")

        page.screenshot(path="verification/during_animation.png")
        
        time.sleep(1)
        page.screenshot(path="verification/after_merge.png")

        browser.close()

if __name__ == "__main__":
    run_verification()
</file>

<file path="verification/verify_particles.py">
import json
from playwright.sync_api import sync_playwright
import time
import os

def run_verification():
    with sync_playwright() as p:
        browser = p.chromium.launch()
        page = browser.new_page()
        
        file_url = f"file://{os.path.abspath('index.html')}"
        page.goto(file_url)
        
        # Check if canvas exists
        canvas = page.query_selector(".game-container canvas")
        if canvas:
            print("SUCCESS: Canvas element found in .game-container.")
        else:
            print("FAILURE: Canvas element not found.")
            exit(1)
            
        # Check if effectManager is initialized
        is_initialized = page.evaluate("!!window.effectManager")
        if is_initialized:
             print("SUCCESS: window.effectManager is initialized.")
        else:
             print("FAILURE: window.effectManager is missing.")
             exit(1)

        # Trigger an explosion manually to check for errors
        try:
            page.evaluate("""
                const container = document.querySelector('.game-container');
                const dummyElement = document.createElement('div');
                dummyElement.style.width = '100px';
                dummyElement.style.height = '100px';
                dummyElement.style.position = 'absolute';
                dummyElement.style.top = '10px';
                dummyElement.style.left = '10px';
                container.appendChild(dummyElement);
                
                window.effectManager.explode(dummyElement, 1024);
                
                container.removeChild(dummyElement);
            """)
            print("SUCCESS: effectManager.explode() called without error.")
        except Exception as e:
            print(f"FAILURE: Error calling effectManager.explode(): {e}")
            exit(1)

        browser.close()

if __name__ == "__main__":
    run_verification()
</file>

<file path="verification/verify_responsive.py">
from playwright.sync_api import sync_playwright
import os

def run():
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True)
        
        # Test Desktop Size
        page = browser.new_page(viewport={"width": 1280, "height": 720})
        cwd = os.getcwd()
        path = f"file://{cwd}/index.html"
        page.goto(path)
        page.wait_for_timeout(1000)
        page.screenshot(path="verification/desktop_layout.png")
        print("Desktop screenshot saved.")
        
        # Test Mobile Size
        page_mobile = browser.new_page(viewport={"width": 375, "height": 667})
        page_mobile.goto(path)
        page_mobile.wait_for_timeout(1000)
        page_mobile.screenshot(path="verification/mobile_layout.png")
        print("Mobile screenshot saved.")
        
        browser.close()

if __name__ == "__main__":
    run()
</file>

<file path="verification/verify_sliding.py">
import time
from playwright.sync_api import sync_playwright
import os
import json

def run():
    with sync_playwright() as p:
        browser = p.chromium.launch()
        # Enable touch support
        page = browser.new_page(has_touch=True)
        
        file_url = f"file://{os.path.abspath('index.html')}"
        
        page.on("console", lambda msg: print(f"CONSOLE: {msg.text}"))
        page.on("pageerror", lambda exc: print(f"PAGE ERROR: {exc}"))
        
        page.goto(file_url)
        
        # Setup simple state: 2 tile at 0,0 (Top-Left)
        # Grid x is col, y is row.
        # x=0, y=0.
        game_state = {
            "grid": {
                "size": 4,
                "cells": [
                    [{"position": {"x": 0, "y": 0}, "value": 2}, None, None, None],
                    [None, None, None, None],
                    [None, None, None, None],
                    [None, None, None, None]
                ]
            },
            "score": 0, "over": False, "won": False, "keepPlaying": False
        }
        page.evaluate(f"window.localStorage.setItem('gameState', '{json.dumps(game_state)}');")
        page.reload()
        
        # 1. Check CSS Transition
        tile = page.wait_for_selector(".tile-2")
        transition = tile.evaluate("el => getComputedStyle(el).transition")
        print(f"Transition computed style: {transition}")
        
        if "0.07s" not in transition and "70ms" not in transition:
            print("FAILURE: CSS Transition property not applied correctly.")
        else:
            print("SUCCESS: CSS Transition property looks correct.")

        # 2. Test Keyboard Move (Right)
        # Move Right -> x=3, y=0 (Slide to edge).
        # Class logic: tile-position-{x+1}-{y+1} -> tile-position-4-1
        page.keyboard.press("ArrowRight")
        try:
            page.wait_for_selector(".tile-position-4-1", state="attached", timeout=1000)
            print("SUCCESS: Keyboard move worked.")
        except:
            print("FAILURE: Keyboard move failed.")

        # 3. Test Touch Swipe (Down)
        # Reset state first
        page.evaluate(f"window.localStorage.setItem('gameState', '{json.dumps(game_state)}');")
        page.reload()
        page.wait_for_selector(".tile-position-1-1") # Ensure it's back at 0,0
        
        # ... existing swipe code ...
        
        container = page.locator(".game-container")
        box = container.bounding_box()
        center_x = box["x"] + box["width"] / 2
        start_y = box["y"] + 10
        end_y = box["y"] + box["height"] - 10
        
        page.mouse.move(center_x, start_y)
        page.mouse.down()
        steps = 5
        for i in range(steps):
            y = start_y + (end_y - start_y) * (i + 1) / steps
            page.mouse.move(center_x, y)
            time.sleep(0.02)
        page.mouse.up()
        
        # Expect move Down -> x=0, y=3
        # Class: tile-position-1-4
        try:
            page.wait_for_selector(".tile-position-1-4", state="attached", timeout=1000)
            print("SUCCESS: Swipe move worked.")
        except:
            print("FAILURE: Swipe move failed.")

        browser.close()

if __name__ == "__main__":
    run()
</file>

</files>
